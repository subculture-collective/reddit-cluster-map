// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: integrity.sql

package db

import (
	"context"
	"database/sql"
)

const countDanglingGraphLinks = `-- name: CountDanglingGraphLinks :one
SELECT COUNT(*) FROM graph_links gl
WHERE NOT EXISTS (SELECT 1 FROM graph_nodes gn WHERE gn.id = gl.source)
   OR NOT EXISTS (SELECT 1 FROM graph_nodes gn WHERE gn.id = gl.target)
`

func (q *Queries) CountDanglingGraphLinks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDanglingGraphLinks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvalidCommentParents = `-- name: CountInvalidCommentParents :one
SELECT COUNT(*) FROM comments c
WHERE c.parent_id IS NOT NULL
  AND c.parent_id NOT LIKE 't1_%'
  AND NOT EXISTS (SELECT 1 FROM posts p WHERE p.id = c.parent_id)
  AND NOT EXISTS (SELECT 1 FROM comments c2 WHERE c2.id = c.parent_id)
`

func (q *Queries) CountInvalidCommentParents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countInvalidCommentParents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrphanComments = `-- name: CountOrphanComments :one
SELECT COUNT(*) FROM comments c
WHERE NOT EXISTS (SELECT 1 FROM posts p WHERE p.id = c.post_id)
   OR NOT EXISTS (SELECT 1 FROM users u WHERE u.id = c.author_id)
   OR NOT EXISTS (SELECT 1 FROM subreddits s WHERE s.id = c.subreddit_id)
`

func (q *Queries) CountOrphanComments(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrphanComments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrphanGraphNodes = `-- name: CountOrphanGraphNodes :one
SELECT COUNT(*) FROM graph_nodes gn
WHERE NOT EXISTS (SELECT 1 FROM graph_links gl WHERE gl.source = gn.id OR gl.target = gn.id)
`

func (q *Queries) CountOrphanGraphNodes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrphanGraphNodes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrphanPosts = `-- name: CountOrphanPosts :one
SELECT COUNT(*) FROM posts p
WHERE NOT EXISTS (SELECT 1 FROM subreddits s WHERE s.id = p.subreddit_id)
   OR NOT EXISTS (SELECT 1 FROM users u WHERE u.id = p.author_id)
`

func (q *Queries) CountOrphanPosts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrphanPosts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteDanglingGraphLinks = `-- name: DeleteDanglingGraphLinks :exec
DELETE FROM graph_links
WHERE id IN (
    SELECT gl.id FROM graph_links gl
    WHERE NOT EXISTS (SELECT 1 FROM graph_nodes gn WHERE gn.id = gl.source)
       OR NOT EXISTS (SELECT 1 FROM graph_nodes gn WHERE gn.id = gl.target)
    LIMIT $1
)
`

// Delete graph_links that reference non-existent nodes
func (q *Queries) DeleteDanglingGraphLinks(ctx context.Context, limit int32) error {
	_, err := q.db.ExecContext(ctx, deleteDanglingGraphLinks, limit)
	return err
}

const deleteOrphanComments = `-- name: DeleteOrphanComments :exec
DELETE FROM comments
WHERE id IN (
    SELECT c.id FROM comments c
    WHERE NOT EXISTS (SELECT 1 FROM posts p WHERE p.id = c.post_id)
       OR NOT EXISTS (SELECT 1 FROM users u WHERE u.id = c.author_id)
       OR NOT EXISTS (SELECT 1 FROM subreddits s WHERE s.id = c.subreddit_id)
    LIMIT $1
)
`

// Delete comments that reference non-existent posts, users, or subreddits
func (q *Queries) DeleteOrphanComments(ctx context.Context, limit int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrphanComments, limit)
	return err
}

const deleteOrphanGraphNodes = `-- name: DeleteOrphanGraphNodes :exec
DELETE FROM graph_nodes
WHERE id IN (
    SELECT gn.id FROM graph_nodes gn
    WHERE NOT EXISTS (SELECT 1 FROM graph_links gl WHERE gl.source = gn.id OR gl.target = gn.id)
    LIMIT $1
)
`

// Delete graph_nodes that have no links
func (q *Queries) DeleteOrphanGraphNodes(ctx context.Context, limit int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrphanGraphNodes, limit)
	return err
}

const deleteOrphanPosts = `-- name: DeleteOrphanPosts :exec
DELETE FROM posts
WHERE id IN (
    SELECT p.id FROM posts p
    WHERE NOT EXISTS (SELECT 1 FROM subreddits s WHERE s.id = p.subreddit_id)
       OR NOT EXISTS (SELECT 1 FROM users u WHERE u.id = p.author_id)
    LIMIT $1
)
`

// Delete posts that reference non-existent subreddits or users
func (q *Queries) DeleteOrphanPosts(ctx context.Context, limit int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrphanPosts, limit)
	return err
}

const findDanglingGraphLinks = `-- name: FindDanglingGraphLinks :many
SELECT gl.id, gl.source, gl.target
FROM graph_links gl
WHERE NOT EXISTS (SELECT 1 FROM graph_nodes gn WHERE gn.id = gl.source)
   OR NOT EXISTS (SELECT 1 FROM graph_nodes gn WHERE gn.id = gl.target)
LIMIT $1 OFFSET $2
`

type FindDanglingGraphLinksParams struct {
	Limit  int32
	Offset int32
}

type FindDanglingGraphLinksRow struct {
	ID     int32
	Source string
	Target string
}

// Find graph_links that reference non-existent nodes
func (q *Queries) FindDanglingGraphLinks(ctx context.Context, arg FindDanglingGraphLinksParams) ([]FindDanglingGraphLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, findDanglingGraphLinks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindDanglingGraphLinksRow
	for rows.Next() {
		var i FindDanglingGraphLinksRow
		if err := rows.Scan(&i.ID, &i.Source, &i.Target); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findInvalidCommentParents = `-- name: FindInvalidCommentParents :many
SELECT c.id, c.parent_id, c.post_id
FROM comments c
WHERE c.parent_id IS NOT NULL
  AND c.parent_id NOT LIKE 't1_%'  -- Not a comment reference
  AND NOT EXISTS (SELECT 1 FROM posts p WHERE p.id = c.parent_id)
  AND NOT EXISTS (SELECT 1 FROM comments c2 WHERE c2.id = c.parent_id)
LIMIT $1 OFFSET $2
`

type FindInvalidCommentParentsParams struct {
	Limit  int32
	Offset int32
}

type FindInvalidCommentParentsRow struct {
	ID       string
	ParentID sql.NullString
	PostID   string
}

// Find comments with parent_id that doesn't exist in comments table
func (q *Queries) FindInvalidCommentParents(ctx context.Context, arg FindInvalidCommentParentsParams) ([]FindInvalidCommentParentsRow, error) {
	rows, err := q.db.QueryContext(ctx, findInvalidCommentParents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindInvalidCommentParentsRow
	for rows.Next() {
		var i FindInvalidCommentParentsRow
		if err := rows.Scan(&i.ID, &i.ParentID, &i.PostID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrphanComments = `-- name: FindOrphanComments :many
SELECT c.id, c.post_id, c.author_id, c.subreddit_id
FROM comments c
WHERE NOT EXISTS (SELECT 1 FROM posts p WHERE p.id = c.post_id)
   OR NOT EXISTS (SELECT 1 FROM users u WHERE u.id = c.author_id)
   OR NOT EXISTS (SELECT 1 FROM subreddits s WHERE s.id = c.subreddit_id)
LIMIT $1 OFFSET $2
`

type FindOrphanCommentsParams struct {
	Limit  int32
	Offset int32
}

type FindOrphanCommentsRow struct {
	ID          string
	PostID      string
	AuthorID    int32
	SubredditID int32
}

// Find comments that reference non-existent posts, users, or subreddits
func (q *Queries) FindOrphanComments(ctx context.Context, arg FindOrphanCommentsParams) ([]FindOrphanCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, findOrphanComments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindOrphanCommentsRow
	for rows.Next() {
		var i FindOrphanCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.AuthorID,
			&i.SubredditID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrphanGraphNodes = `-- name: FindOrphanGraphNodes :many
SELECT gn.id, gn.name, gn.type
FROM graph_nodes gn
WHERE NOT EXISTS (SELECT 1 FROM graph_links gl WHERE gl.source = gn.id OR gl.target = gn.id)
LIMIT $1 OFFSET $2
`

type FindOrphanGraphNodesParams struct {
	Limit  int32
	Offset int32
}

type FindOrphanGraphNodesRow struct {
	ID   string
	Name string
	Type sql.NullString
}

// Find graph_nodes that have no links (neither as source nor target)
func (q *Queries) FindOrphanGraphNodes(ctx context.Context, arg FindOrphanGraphNodesParams) ([]FindOrphanGraphNodesRow, error) {
	rows, err := q.db.QueryContext(ctx, findOrphanGraphNodes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindOrphanGraphNodesRow
	for rows.Next() {
		var i FindOrphanGraphNodesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Type); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrphanPosts = `-- name: FindOrphanPosts :many
SELECT p.id, p.subreddit_id, p.author_id, p.title
FROM posts p
WHERE NOT EXISTS (SELECT 1 FROM subreddits s WHERE s.id = p.subreddit_id)
   OR NOT EXISTS (SELECT 1 FROM users u WHERE u.id = p.author_id)
LIMIT $1 OFFSET $2
`

type FindOrphanPostsParams struct {
	Limit  int32
	Offset int32
}

type FindOrphanPostsRow struct {
	ID          string
	SubredditID int32
	AuthorID    int32
	Title       sql.NullString
}

// Find posts that reference non-existent subreddits or users
func (q *Queries) FindOrphanPosts(ctx context.Context, arg FindOrphanPostsParams) ([]FindOrphanPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, findOrphanPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindOrphanPostsRow
	for rows.Next() {
		var i FindOrphanPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.AuthorID,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleData = `-- name: GetStaleData :many
SELECT 
    'user' as entity_type,
    username as entity_name,
    last_seen,
    EXTRACT(EPOCH FROM (NOW() - last_seen))/86400 as days_since_seen
FROM users
WHERE last_seen < NOW() - INTERVAL '30 days'
UNION ALL
SELECT 
    'subreddit' as entity_type,
    name as entity_name,
    last_seen,
    EXTRACT(EPOCH FROM (NOW() - last_seen))/86400 as days_since_seen
FROM subreddits
WHERE last_seen < NOW() - INTERVAL '30 days'
ORDER BY days_since_seen DESC
LIMIT $1 OFFSET $2
`

type GetStaleDataParams struct {
	Limit  int32
	Offset int32
}

type GetStaleDataRow struct {
	EntityType    string
	EntityName    string
	LastSeen      sql.NullTime
	DaysSinceSeen int32
}

// Find data that hasn't been updated in a long time (potential for backfill)
func (q *Queries) GetStaleData(ctx context.Context, arg GetStaleDataParams) ([]GetStaleDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getStaleData, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStaleDataRow
	for rows.Next() {
		var i GetStaleDataRow
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityName,
			&i.LastSeen,
			&i.DaysSinceSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
