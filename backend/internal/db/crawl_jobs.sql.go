// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: crawl_jobs.sql

package db

import (
	"context"
	"database/sql"
)

const crawlJobExists = `-- name: CrawlJobExists :one
SELECT EXISTS (
	SELECT 1
	FROM crawl_jobs
	WHERE subreddit_id = $1
)
`

func (q *Queries) CrawlJobExists(ctx context.Context, subredditID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, crawlJobExists, subredditID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const enqueueCrawlJob = `-- name: EnqueueCrawlJob :exec
INSERT INTO crawl_jobs (subreddit_id, status, retries, enqueued_by)
SELECT $1, 'queued', 0, $2
WHERE NOT EXISTS (SELECT 1 FROM crawl_jobs WHERE subreddit_id = $1)
`

type EnqueueCrawlJobParams struct {
	SubredditID int32
	EnqueuedBy  sql.NullString
}

func (q *Queries) EnqueueCrawlJob(ctx context.Context, arg EnqueueCrawlJobParams) error {
	_, err := q.db.ExecContext(ctx, enqueueCrawlJob, arg.SubredditID, arg.EnqueuedBy)
	return err
}

const listCrawlJobs = `-- name: ListCrawlJobs :many
SELECT
  id,
  subreddit_id,
  status,
  retries,
  priority,
  last_attempt,
  enqueued_by,
  created_at,
  updated_at
FROM crawl_jobs
ORDER BY created_at DESC
LIMIT $1::int OFFSET $2::int
`

type ListCrawlJobsParams struct {
	Column1 int32
	Column2 int32
}

type ListCrawlJobsRow struct {
	ID          int32
	SubredditID int32
	Status      string
	Retries     sql.NullInt32
	Priority    sql.NullInt32
	LastAttempt sql.NullTime
	EnqueuedBy  sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) ListCrawlJobs(ctx context.Context, arg ListCrawlJobsParams) ([]ListCrawlJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCrawlJobs, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCrawlJobsRow
	for rows.Next() {
		var i ListCrawlJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.Status,
			&i.Retries,
			&i.Priority,
			&i.LastAttempt,
			&i.EnqueuedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueueWithNames = `-- name: ListQueueWithNames :many
SELECT cj.id, cj.subreddit_id, s.name AS subreddit_name, cj.status, cj.priority, cj.created_at, cj.updated_at
FROM crawl_jobs cj
JOIN subreddits s ON s.id = cj.subreddit_id
WHERE cj.status IN ('queued','crawling')
ORDER BY cj.priority DESC, cj.created_at ASC
`

type ListQueueWithNamesRow struct {
	ID            int32
	SubredditID   int32
	SubredditName string
	Status        string
	Priority      sql.NullInt32
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
}

func (q *Queries) ListQueueWithNames(ctx context.Context) ([]ListQueueWithNamesRow, error) {
	rows, err := q.db.QueryContext(ctx, listQueueWithNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListQueueWithNamesRow
	for rows.Next() {
		var i ListQueueWithNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.SubredditName,
			&i.Status,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCrawlJobFailed = `-- name: MarkCrawlJobFailed :exec
UPDATE crawl_jobs SET status = 'failed', retries = retries + 1, updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobFailed(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobFailed, id)
	return err
}

const markCrawlJobStarted = `-- name: MarkCrawlJobStarted :exec
UPDATE crawl_jobs SET status = 'crawling', last_attempt = now(), updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobStarted(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobStarted, id)
	return err
}

const markCrawlJobSuccess = `-- name: MarkCrawlJobSuccess :exec
UPDATE crawl_jobs SET status = 'success', updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobSuccess(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobSuccess, id)
	return err
}
