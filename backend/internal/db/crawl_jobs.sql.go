// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: crawl_jobs.sql

package db

import (
	"context"
	"database/sql"
)

const ageStarvedJobs = `-- name: AgeStarvedJobs :exec
UPDATE crawl_jobs
SET priority = priority + $2,
    updated_at = now()
WHERE status = 'queued'
  AND created_at < now() - $1::interval
  AND priority < 100
`

type AgeStarvedJobsParams struct {
	Column1  int64
	Priority sql.NullInt32
}

func (q *Queries) AgeStarvedJobs(ctx context.Context, arg AgeStarvedJobsParams) error {
	_, err := q.db.ExecContext(ctx, ageStarvedJobs, arg.Column1, arg.Priority)
	return err
}

const claimNextJobWithTimeout = `-- name: ClaimNextJobWithTimeout :one
SELECT id, subreddit_id, status, retries, priority, last_attempt, duration_ms, enqueued_by, created_at, updated_at
FROM crawl_jobs
WHERE status = 'queued' AND visible_at <= now()
ORDER BY priority DESC, created_at ASC
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type ClaimNextJobWithTimeoutRow struct {
	ID          int32
	SubredditID int32
	Status      string
	Retries     sql.NullInt32
	Priority    sql.NullInt32
	LastAttempt sql.NullTime
	DurationMs  sql.NullInt32
	EnqueuedBy  sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) ClaimNextJobWithTimeout(ctx context.Context) (ClaimNextJobWithTimeoutRow, error) {
	row := q.db.QueryRowContext(ctx, claimNextJobWithTimeout)
	var i ClaimNextJobWithTimeoutRow
	err := row.Scan(
		&i.ID,
		&i.SubredditID,
		&i.Status,
		&i.Retries,
		&i.Priority,
		&i.LastAttempt,
		&i.DurationMs,
		&i.EnqueuedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crawlJobExists = `-- name: CrawlJobExists :one
SELECT EXISTS (
	SELECT 1
	FROM crawl_jobs
	WHERE subreddit_id = $1
)
`

func (q *Queries) CrawlJobExists(ctx context.Context, subredditID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, crawlJobExists, subredditID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const enqueueCrawlJob = `-- name: EnqueueCrawlJob :exec
INSERT INTO crawl_jobs (subreddit_id, status, retries, enqueued_by)
SELECT $1, 'queued', 0, $2
WHERE NOT EXISTS (SELECT 1 FROM crawl_jobs WHERE subreddit_id = $1)
`

type EnqueueCrawlJobParams struct {
	SubredditID int32
	EnqueuedBy  sql.NullString
}

func (q *Queries) EnqueueCrawlJob(ctx context.Context, arg EnqueueCrawlJobParams) error {
	_, err := q.db.ExecContext(ctx, enqueueCrawlJob, arg.SubredditID, arg.EnqueuedBy)
	return err
}

const listCrawlJobs = `-- name: ListCrawlJobs :many
SELECT
  id,
  subreddit_id,
  status,
  retries,
  priority,
  last_attempt,
  enqueued_by,
  created_at,
  updated_at
FROM crawl_jobs
ORDER BY created_at DESC
LIMIT $1::int OFFSET $2::int
`

type ListCrawlJobsParams struct {
	Column1 int32
	Column2 int32
}

type ListCrawlJobsRow struct {
	ID          int32
	SubredditID int32
	Status      string
	Retries     sql.NullInt32
	Priority    sql.NullInt32
	LastAttempt sql.NullTime
	EnqueuedBy  sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) ListCrawlJobs(ctx context.Context, arg ListCrawlJobsParams) ([]ListCrawlJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCrawlJobs, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCrawlJobsRow
	for rows.Next() {
		var i ListCrawlJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.Status,
			&i.Retries,
			&i.Priority,
			&i.LastAttempt,
			&i.EnqueuedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueueWithNames = `-- name: ListQueueWithNames :many
SELECT cj.id, cj.subreddit_id, s.name AS subreddit_name, cj.status, cj.priority, cj.created_at, cj.updated_at
FROM crawl_jobs cj
JOIN subreddits s ON s.id = cj.subreddit_id
WHERE cj.status IN ('queued','crawling')
ORDER BY cj.priority DESC, cj.created_at ASC
`

type ListQueueWithNamesRow struct {
	ID            int32
	SubredditID   int32
	SubredditName string
	Status        string
	Priority      sql.NullInt32
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
}

func (q *Queries) ListQueueWithNames(ctx context.Context) ([]ListQueueWithNamesRow, error) {
	rows, err := q.db.QueryContext(ctx, listQueueWithNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListQueueWithNamesRow
	for rows.Next() {
		var i ListQueueWithNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.SubredditName,
			&i.Status,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCrawlJobFailed = `-- name: MarkCrawlJobFailed :exec
UPDATE crawl_jobs SET status = 'failed', retries = retries + 1, updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobFailed(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobFailed, id)
	return err
}

const markCrawlJobStarted = `-- name: MarkCrawlJobStarted :exec
UPDATE crawl_jobs SET status = 'crawling', last_attempt = now(), updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobStarted(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobStarted, id)
	return err
}

const markCrawlJobSuccess = `-- name: MarkCrawlJobSuccess :exec
UPDATE crawl_jobs SET status = 'success', updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobSuccess(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobSuccess, id)
	return err
}

const markJobFailedWithRetry = `-- name: MarkJobFailedWithRetry :exec
UPDATE crawl_jobs 
SET status = 'failed',
    retry_count = retry_count + 1,
    next_retry_at = $2,
    updated_at = now()
WHERE id = $1
`

type MarkJobFailedWithRetryParams struct {
	ID          int32
	NextRetryAt sql.NullTime
}

func (q *Queries) MarkJobFailedWithRetry(ctx context.Context, arg MarkJobFailedWithRetryParams) error {
	_, err := q.db.ExecContext(ctx, markJobFailedWithRetry, arg.ID, arg.NextRetryAt)
	return err
}

const requeueRetryableJobs = `-- name: RequeueRetryableJobs :exec
UPDATE crawl_jobs
SET status = 'queued',
    visible_at = now(),
    updated_at = now()
WHERE status = 'failed' 
  AND next_retry_at IS NOT NULL 
  AND next_retry_at <= now()
  AND retry_count < max_retries
`

func (q *Queries) RequeueRetryableJobs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, requeueRetryableJobs)
	return err
}

const updateJobVisibilityTimeout = `-- name: UpdateJobVisibilityTimeout :exec
UPDATE crawl_jobs 
SET visible_at = $2, updated_at = now() 
WHERE id = $1
`

type UpdateJobVisibilityTimeoutParams struct {
	ID        int32
	VisibleAt sql.NullTime
}

func (q *Queries) UpdateJobVisibilityTimeout(ctx context.Context, arg UpdateJobVisibilityTimeoutParams) error {
	_, err := q.db.ExecContext(ctx, updateJobVisibilityTimeout, arg.ID, arg.VisibleAt)
	return err
}
