// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: graph.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const bulkInsertGraphLink = `-- name: BulkInsertGraphLink :exec
INSERT INTO graph_links (source, target)
SELECT $1, $2
WHERE EXISTS (SELECT 1 FROM graph_nodes WHERE id = $1)
    AND EXISTS (SELECT 1 FROM graph_nodes WHERE id = $2)
ON CONFLICT (source, target) DO NOTHING
`

type BulkInsertGraphLinkParams struct {
	Source string
	Target string
}

func (q *Queries) BulkInsertGraphLink(ctx context.Context, arg BulkInsertGraphLinkParams) error {
	_, err := q.db.ExecContext(ctx, bulkInsertGraphLink, arg.Source, arg.Target)
	return err
}

const bulkInsertGraphNode = `-- name: BulkInsertGraphNode :exec
INSERT INTO graph_nodes (
    id,
    name,
    val,
    type
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (id) DO UPDATE
SET
    name = EXCLUDED.name,
    val = EXCLUDED.val,
    type = EXCLUDED.type,
    updated_at = now()
`

type BulkInsertGraphNodeParams struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
}

func (q *Queries) BulkInsertGraphNode(ctx context.Context, arg BulkInsertGraphNodeParams) error {
	_, err := q.db.ExecContext(ctx, bulkInsertGraphNode,
		arg.ID,
		arg.Name,
		arg.Val,
		arg.Type,
	)
	return err
}

const clearCommunityHierarchy = `-- name: ClearCommunityHierarchy :exec

TRUNCATE TABLE graph_community_hierarchy
`

// ============================================================
// Community Hierarchy Queries
// ============================================================
func (q *Queries) ClearCommunityHierarchy(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearCommunityHierarchy)
	return err
}

const clearCommunityTables = `-- name: ClearCommunityTables :exec

TRUNCATE TABLE graph_communities CASCADE
`

// ============================================================
// Community Detection Queries
// ============================================================
func (q *Queries) ClearCommunityTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearCommunityTables)
	return err
}

const clearGraphTables = `-- name: ClearGraphTables :exec
TRUNCATE TABLE graph_nodes, graph_links
`

func (q *Queries) ClearGraphTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearGraphTables)
	return err
}

const clearSubredditRelationships = `-- name: ClearSubredditRelationships :exec
TRUNCATE TABLE subreddit_relationships
`

func (q *Queries) ClearSubredditRelationships(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearSubredditRelationships)
	return err
}

const clearUserSubredditActivity = `-- name: ClearUserSubredditActivity :exec
TRUNCATE TABLE user_subreddit_activity
`

func (q *Queries) ClearUserSubredditActivity(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearUserSubredditActivity)
	return err
}

const countNodesInBoundingBox = `-- name: CountNodesInBoundingBox :one
SELECT COUNT(*)
FROM graph_nodes
WHERE pos_x IS NOT NULL
  AND pos_y IS NOT NULL
  AND pos_z IS NOT NULL
  AND pos_x BETWEEN $1 AND $2
  AND pos_y BETWEEN $3 AND $4
  AND pos_z BETWEEN $5 AND $6
`

type CountNodesInBoundingBoxParams struct {
	PosX   sql.NullFloat64
	PosX_2 sql.NullFloat64
	PosY   sql.NullFloat64
	PosY_2 sql.NullFloat64
	PosZ   sql.NullFloat64
	PosZ_2 sql.NullFloat64
}

// Count nodes within a bounding box (useful for pagination)
// Parameters: x_min, x_max, y_min, y_max, z_min, z_max
func (q *Queries) CountNodesInBoundingBox(ctx context.Context, arg CountNodesInBoundingBoxParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNodesInBoundingBox,
		arg.PosX,
		arg.PosX_2,
		arg.PosY,
		arg.PosY_2,
		arg.PosZ,
		arg.PosZ_2,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCommunity = `-- name: CreateCommunity :one
INSERT INTO graph_communities (
    label,
    size,
    modularity
) VALUES (
    $1, $2, $3
) RETURNING id, label, size, modularity, created_at, updated_at
`

type CreateCommunityParams struct {
	Label      string
	Size       int32
	Modularity sql.NullFloat64
}

func (q *Queries) CreateCommunity(ctx context.Context, arg CreateCommunityParams) (GraphCommunity, error) {
	row := q.db.QueryRowContext(ctx, createCommunity, arg.Label, arg.Size, arg.Modularity)
	var i GraphCommunity
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Size,
		&i.Modularity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCommunityLink = `-- name: CreateCommunityLink :exec
INSERT INTO graph_community_links (
    source_community_id,
    target_community_id,
    weight
) VALUES (
    $1, $2, $3
) ON CONFLICT (source_community_id, target_community_id)
DO UPDATE SET weight = EXCLUDED.weight, updated_at = now()
`

type CreateCommunityLinkParams struct {
	SourceCommunityID int32
	TargetCommunityID int32
	Weight            int32
}

func (q *Queries) CreateCommunityLink(ctx context.Context, arg CreateCommunityLinkParams) error {
	_, err := q.db.ExecContext(ctx, createCommunityLink, arg.SourceCommunityID, arg.TargetCommunityID, arg.Weight)
	return err
}

const createCommunityMember = `-- name: CreateCommunityMember :exec
INSERT INTO graph_community_members (
    community_id,
    node_id
) VALUES (
    $1, $2
) ON CONFLICT (community_id, node_id) DO NOTHING
`

type CreateCommunityMemberParams struct {
	CommunityID int32
	NodeID      string
}

func (q *Queries) CreateCommunityMember(ctx context.Context, arg CreateCommunityMemberParams) error {
	_, err := q.db.ExecContext(ctx, createCommunityMember, arg.CommunityID, arg.NodeID)
	return err
}

const createGraphLink = `-- name: CreateGraphLink :one
INSERT INTO graph_links (
    source,
    target
) VALUES (
    $1, $2
) RETURNING id, source, target, created_at, updated_at
`

type CreateGraphLinkParams struct {
	Source string
	Target string
}

func (q *Queries) CreateGraphLink(ctx context.Context, arg CreateGraphLinkParams) (GraphLink, error) {
	row := q.db.QueryRowContext(ctx, createGraphLink, arg.Source, arg.Target)
	var i GraphLink
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Target,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubredditRelationship = `-- name: CreateSubredditRelationship :one
INSERT INTO subreddit_relationships (
    source_subreddit_id,
    target_subreddit_id,
    overlap_count
) VALUES (
    $1, $2, $3
) ON CONFLICT (source_subreddit_id, target_subreddit_id)
DO UPDATE SET
    overlap_count = EXCLUDED.overlap_count,
    updated_at = now()
RETURNING id, source_subreddit_id, target_subreddit_id, overlap_count, created_at, updated_at
`

type CreateSubredditRelationshipParams struct {
	SourceSubredditID int32
	TargetSubredditID int32
	OverlapCount      int32
}

func (q *Queries) CreateSubredditRelationship(ctx context.Context, arg CreateSubredditRelationshipParams) (SubredditRelationship, error) {
	row := q.db.QueryRowContext(ctx, createSubredditRelationship, arg.SourceSubredditID, arg.TargetSubredditID, arg.OverlapCount)
	var i SubredditRelationship
	err := row.Scan(
		&i.ID,
		&i.SourceSubredditID,
		&i.TargetSubredditID,
		&i.OverlapCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserSubredditActivity = `-- name: CreateUserSubredditActivity :one
INSERT INTO user_subreddit_activity (
    user_id,
    subreddit_id,
    activity_count
) VALUES (
    $1, $2, $3
) RETURNING id, user_id, subreddit_id, activity_count, created_at, updated_at
`

type CreateUserSubredditActivityParams struct {
	UserID        int32
	SubredditID   int32
	ActivityCount int32
}

func (q *Queries) CreateUserSubredditActivity(ctx context.Context, arg CreateUserSubredditActivityParams) (UserSubredditActivity, error) {
	row := q.db.QueryRowContext(ctx, createUserSubredditActivity, arg.UserID, arg.SubredditID, arg.ActivityCount)
	var i UserSubredditActivity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubredditID,
		&i.ActivityCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllComments = `-- name: GetAllComments :many
SELECT id, body, score, post_id
FROM comments
`

type GetAllCommentsRow struct {
	ID     string
	Body   sql.NullString
	Score  sql.NullInt32
	PostID string
}

func (q *Queries) GetAllComments(ctx context.Context) ([]GetAllCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllComments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCommentsRow
	for rows.Next() {
		var i GetAllCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.Score,
			&i.PostID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCommunities = `-- name: GetAllCommunities :many
SELECT id, label, size, modularity, created_at, updated_at FROM graph_communities
ORDER BY size DESC
`

func (q *Queries) GetAllCommunities(ctx context.Context) ([]GraphCommunity, error) {
	rows, err := q.db.QueryContext(ctx, getAllCommunities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GraphCommunity
	for rows.Next() {
		var i GraphCommunity
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Size,
			&i.Modularity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many
SELECT id, title, score
FROM posts
`

type GetAllPostsRow struct {
	ID    string
	Title sql.NullString
	Score sql.NullInt32
}

func (q *Queries) GetAllPosts(ctx context.Context) ([]GetAllPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPostsRow
	for rows.Next() {
		var i GetAllPostsRow
		if err := rows.Scan(&i.ID, &i.Title, &i.Score); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubredditRelationships = `-- name: GetAllSubredditRelationships :many
SELECT source_subreddit_id, target_subreddit_id, overlap_count
FROM subreddit_relationships
`

type GetAllSubredditRelationshipsRow struct {
	SourceSubredditID int32
	TargetSubredditID int32
	OverlapCount      int32
}

func (q *Queries) GetAllSubredditRelationships(ctx context.Context) ([]GetAllSubredditRelationshipsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubredditRelationships)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubredditRelationshipsRow
	for rows.Next() {
		var i GetAllSubredditRelationshipsRow
		if err := rows.Scan(&i.SourceSubredditID, &i.TargetSubredditID, &i.OverlapCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubreddits = `-- name: GetAllSubreddits :many
SELECT id, name, subscribers
FROM subreddits
`

type GetAllSubredditsRow struct {
	ID          int32
	Name        string
	Subscribers sql.NullInt32
}

func (q *Queries) GetAllSubreddits(ctx context.Context) ([]GetAllSubredditsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubreddits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubredditsRow
	for rows.Next() {
		var i GetAllSubredditsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Subscribers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserSubredditActivity = `-- name: GetAllUserSubredditActivity :many
SELECT user_id, subreddit_id, activity_count
FROM user_subreddit_activity
`

type GetAllUserSubredditActivityRow struct {
	UserID        int32
	SubredditID   int32
	ActivityCount int32
}

func (q *Queries) GetAllUserSubredditActivity(ctx context.Context) ([]GetAllUserSubredditActivityRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserSubredditActivity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserSubredditActivityRow
	for rows.Next() {
		var i GetAllUserSubredditActivityRow
		if err := rows.Scan(&i.UserID, &i.SubredditID, &i.ActivityCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, username
FROM users
`

type GetAllUsersRow struct {
	ID       int32
	Username string
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(&i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunitiesAtLevel = `-- name: GetCommunitiesAtLevel :many
SELECT 
    community_id,
    COUNT(*) as member_count,
    AVG(centroid_x) as avg_x,
    AVG(centroid_y) as avg_y,
    AVG(centroid_z) as avg_z
FROM graph_community_hierarchy
WHERE level = $1
GROUP BY community_id
ORDER BY member_count DESC
`

type GetCommunitiesAtLevelRow struct {
	CommunityID int32
	MemberCount int64
	AvgX        float64
	AvgY        float64
	AvgZ        float64
}

func (q *Queries) GetCommunitiesAtLevel(ctx context.Context, level int32) ([]GetCommunitiesAtLevelRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunitiesAtLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunitiesAtLevelRow
	for rows.Next() {
		var i GetCommunitiesAtLevelRow
		if err := rows.Scan(
			&i.CommunityID,
			&i.MemberCount,
			&i.AvgX,
			&i.AvgY,
			&i.AvgZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunity = `-- name: GetCommunity :one
SELECT id, label, size, modularity, created_at, updated_at FROM graph_communities
WHERE id = $1
`

func (q *Queries) GetCommunity(ctx context.Context, id int32) (GraphCommunity, error) {
	row := q.db.QueryRowContext(ctx, getCommunity, id)
	var i GraphCommunity
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Size,
		&i.Modularity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCommunityHierarchy = `-- name: GetCommunityHierarchy :many
SELECT 
    node_id,
    level,
    community_id,
    parent_community_id,
    centroid_x,
    centroid_y,
    centroid_z
FROM graph_community_hierarchy
ORDER BY level, community_id, node_id
`

type GetCommunityHierarchyRow struct {
	NodeID            string
	Level             int32
	CommunityID       int32
	ParentCommunityID sql.NullInt32
	CentroidX         sql.NullFloat64
	CentroidY         sql.NullFloat64
	CentroidZ         sql.NullFloat64
}

func (q *Queries) GetCommunityHierarchy(ctx context.Context) ([]GetCommunityHierarchyRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityHierarchy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunityHierarchyRow
	for rows.Next() {
		var i GetCommunityHierarchyRow
		if err := rows.Scan(
			&i.NodeID,
			&i.Level,
			&i.CommunityID,
			&i.ParentCommunityID,
			&i.CentroidX,
			&i.CentroidY,
			&i.CentroidZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityLinks = `-- name: GetCommunityLinks :many
SELECT
    'link' as data_type,
    CAST(gcl.source_community_id || '_' || gcl.target_community_id AS TEXT) as id,
    NULL as name,
    CAST(gcl.weight AS TEXT) as val,
    NULL as type,
    NULL as pos_x,
    NULL as pos_y,
    NULL as pos_z,
    CAST('community_' || gcl.source_community_id AS TEXT) as source,
    CAST('community_' || gcl.target_community_id AS TEXT) as target
FROM graph_community_links gcl
ORDER BY gcl.weight DESC
LIMIT $1
`

type GetCommunityLinksRow struct {
	DataType string
	ID       string
	Name     interface{}
	Val      string
	Type     interface{}
	PosX     interface{}
	PosY     interface{}
	PosZ     interface{}
	Source   string
	Target   string
}

func (q *Queries) GetCommunityLinks(ctx context.Context, limit int32) ([]GetCommunityLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityLinks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunityLinksRow
	for rows.Next() {
		var i GetCommunityLinksRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityMembers = `-- name: GetCommunityMembers :many
SELECT node_id FROM graph_community_members
WHERE community_id = $1
`

func (q *Queries) GetCommunityMembers(ctx context.Context, communityID int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityMembers, communityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var node_id string
		if err := rows.Scan(&node_id); err != nil {
			return nil, err
		}
		items = append(items, node_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunitySubgraph = `-- name: GetCommunitySubgraph :many
WITH member_nodes AS (
    SELECT node_id FROM graph_community_members
    WHERE community_id = $1
)
SELECT
    'node' as data_type,
    gn.id,
    gn.name,
    CAST(gn.val AS TEXT) as val,
    gn.type,
    gn.pos_x,
    gn.pos_y,
    gn.pos_z,
    NULL as source,
    NULL as target
FROM graph_nodes gn
WHERE gn.id IN (SELECT node_id FROM member_nodes)
UNION ALL
SELECT
    'link' as data_type,
    CAST(gl.id AS TEXT),
    NULL as name,
    CAST(NULL AS TEXT) as val,
    NULL as type,
    NULL as pos_x,
    NULL as pos_y,
    NULL as pos_z,
    gl.source,
    gl.target
FROM graph_links gl
WHERE gl.source IN (SELECT node_id FROM member_nodes)
    AND gl.target IN (SELECT node_id FROM member_nodes)
ORDER BY data_type, id
LIMIT $2
`

type GetCommunitySubgraphParams struct {
	CommunityID int32
	Limit       int32
}

type GetCommunitySubgraphRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     sql.NullString
	PosX     sql.NullFloat64
	PosY     sql.NullFloat64
	PosZ     sql.NullFloat64
	Source   interface{}
	Target   interface{}
}

func (q *Queries) GetCommunitySubgraph(ctx context.Context, arg GetCommunitySubgraphParams) ([]GetCommunitySubgraphRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunitySubgraph, arg.CommunityID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunitySubgraphRow
	for rows.Next() {
		var i GetCommunitySubgraphRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunitySupernodesWithPositions = `-- name: GetCommunitySupernodesWithPositions :many
WITH community_stats AS (
    SELECT 
        gc.id,
        gc.label,
        gc.size,
        gc.modularity,
        AVG(gn.pos_x) as avg_x,
        AVG(gn.pos_y) as avg_y,
        AVG(gn.pos_z) as avg_z
    FROM graph_communities gc
    LEFT JOIN graph_community_members gcm ON gc.id = gcm.community_id
    LEFT JOIN graph_nodes gn ON gcm.node_id = gn.id
    GROUP BY gc.id, gc.label, gc.size, gc.modularity
)
SELECT 
    'node' as data_type,
    CAST('community_' || id AS TEXT) as id,
    label as name,
    CAST(size AS TEXT) as val,
    'community' as type,
    avg_x as pos_x,
    avg_y as pos_y,
    avg_z as pos_z,
    NULL as source,
    NULL as target
FROM community_stats
ORDER BY size DESC
`

type GetCommunitySupernodesWithPositionsRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     string
	PosX     float64
	PosY     float64
	PosZ     float64
	Source   interface{}
	Target   interface{}
}

func (q *Queries) GetCommunitySupernodesWithPositions(ctx context.Context) ([]GetCommunitySupernodesWithPositionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunitySupernodesWithPositions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunitySupernodesWithPositionsRow
	for rows.Next() {
		var i GetCommunitySupernodesWithPositionsRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHierarchyLevels = `-- name: GetHierarchyLevels :many
SELECT DISTINCT level
FROM graph_community_hierarchy
ORDER BY level
`

func (q *Queries) GetHierarchyLevels(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getHierarchyLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var level int32
		if err := rows.Scan(&level); err != nil {
			return nil, err
		}
		items = append(items, level)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinksForNodesInBoundingBox = `-- name: GetLinksForNodesInBoundingBox :many
WITH bbox_nodes AS (
    SELECT id
    FROM graph_nodes
    WHERE pos_x IS NOT NULL
      AND pos_y IS NOT NULL
      AND pos_z IS NOT NULL
      AND pos_x BETWEEN $1 AND $2
      AND pos_y BETWEEN $3 AND $4
      AND pos_z BETWEEN $5 AND $6
)
SELECT 
    gl.id,
    gl.source,
    gl.target
FROM graph_links gl
WHERE EXISTS (SELECT 1 FROM bbox_nodes WHERE id = gl.source)
  AND EXISTS (SELECT 1 FROM bbox_nodes WHERE id = gl.target)
LIMIT $7
`

type GetLinksForNodesInBoundingBoxParams struct {
	PosX   sql.NullFloat64
	PosX_2 sql.NullFloat64
	PosY   sql.NullFloat64
	PosY_2 sql.NullFloat64
	PosZ   sql.NullFloat64
	PosZ_2 sql.NullFloat64
	Limit  int32
}

type GetLinksForNodesInBoundingBoxRow struct {
	ID     int32
	Source string
	Target string
}

// Retrieves links where both source and target nodes are within the bounding box
// Uses the same spatial filtering approach
// Parameters: x_min, x_max, y_min, y_max, z_min, z_max, limit
func (q *Queries) GetLinksForNodesInBoundingBox(ctx context.Context, arg GetLinksForNodesInBoundingBoxParams) ([]GetLinksForNodesInBoundingBoxRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinksForNodesInBoundingBox,
		arg.PosX,
		arg.PosX_2,
		arg.PosY,
		arg.PosY_2,
		arg.PosZ,
		arg.PosZ_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksForNodesInBoundingBoxRow
	for rows.Next() {
		var i GetLinksForNodesInBoundingBoxRow
		if err := rows.Scan(&i.ID, &i.Source, &i.Target); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesAtLevel = `-- name: GetNodesAtLevel :many
SELECT 
    node_id,
    community_id,
    parent_community_id,
    centroid_x,
    centroid_y,
    centroid_z
FROM graph_community_hierarchy
WHERE level = $1
ORDER BY community_id, node_id
`

type GetNodesAtLevelRow struct {
	NodeID            string
	CommunityID       int32
	ParentCommunityID sql.NullInt32
	CentroidX         sql.NullFloat64
	CentroidY         sql.NullFloat64
	CentroidZ         sql.NullFloat64
}

func (q *Queries) GetNodesAtLevel(ctx context.Context, level int32) ([]GetNodesAtLevelRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodesAtLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodesAtLevelRow
	for rows.Next() {
		var i GetNodesAtLevelRow
		if err := rows.Scan(
			&i.NodeID,
			&i.CommunityID,
			&i.ParentCommunityID,
			&i.CentroidX,
			&i.CentroidY,
			&i.CentroidZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesInBoundingBox = `-- name: GetNodesInBoundingBox :many
SELECT 
    id,
    name,
    val,
    type,
    pos_x,
    pos_y,
    pos_z
FROM graph_nodes
WHERE pos_x IS NOT NULL
  AND pos_y IS NOT NULL
  AND pos_z IS NOT NULL
  AND pos_x BETWEEN $1 AND $2
  AND pos_y BETWEEN $3 AND $4
  AND pos_z BETWEEN $5 AND $6
ORDER BY (
    CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END
) DESC NULLS LAST, id
LIMIT $7
`

type GetNodesInBoundingBoxParams struct {
	PosX   sql.NullFloat64
	PosX_2 sql.NullFloat64
	PosY   sql.NullFloat64
	PosY_2 sql.NullFloat64
	PosZ   sql.NullFloat64
	PosZ_2 sql.NullFloat64
	Limit  int32
}

type GetNodesInBoundingBoxRow struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

// Retrieves nodes within a 3D bounding box using the spatial index
// Parameters: x_min, x_max, y_min, y_max, z_min, z_max, limit
// The spatial index (idx_graph_nodes_spatial_nonnull) makes this query efficient
func (q *Queries) GetNodesInBoundingBox(ctx context.Context, arg GetNodesInBoundingBoxParams) ([]GetNodesInBoundingBoxRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodesInBoundingBox,
		arg.PosX,
		arg.PosX_2,
		arg.PosY,
		arg.PosY_2,
		arg.PosZ,
		arg.PosZ_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodesInBoundingBoxRow
	for rows.Next() {
		var i GetNodesInBoundingBoxRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesInBoundingBox2D = `-- name: GetNodesInBoundingBox2D :many
SELECT 
    id,
    name,
    val,
    type,
    pos_x,
    pos_y,
    pos_z
FROM graph_nodes
WHERE pos_x IS NOT NULL
  AND pos_y IS NOT NULL
  AND pos_z IS NOT NULL
  AND pos_x BETWEEN $1 AND $2
  AND pos_y BETWEEN $3 AND $4
ORDER BY (
    CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END
) DESC NULLS LAST, id
LIMIT $5
`

type GetNodesInBoundingBox2DParams struct {
	PosX   sql.NullFloat64
	PosX_2 sql.NullFloat64
	PosY   sql.NullFloat64
	PosY_2 sql.NullFloat64
	Limit  int32
}

type GetNodesInBoundingBox2DRow struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

// Retrieves nodes within a 2D bounding box (ignoring z coordinate)
// Parameters: x_min, x_max, y_min, y_max, limit
// Useful for 2D viewport queries where z is not relevant
// Note: Includes pos_z IS NOT NULL to match the partial GiST index predicate (which requires all position columns to be non-null)
func (q *Queries) GetNodesInBoundingBox2D(ctx context.Context, arg GetNodesInBoundingBox2DParams) ([]GetNodesInBoundingBox2DRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodesInBoundingBox2D,
		arg.PosX,
		arg.PosX_2,
		arg.PosY,
		arg.PosY_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodesInBoundingBox2DRow
	for rows.Next() {
		var i GetNodesInBoundingBox2DRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrecalculatedGraphDataCappedAll = `-- name: GetPrecalculatedGraphDataCappedAll :many
WITH sel_nodes AS (
    SELECT gn.id, gn.name, gn.val, gn.type, gn.pos_x, gn.pos_y, gn.pos_z
    FROM graph_nodes gn
    ORDER BY (
        CASE WHEN gn.val ~ '^[0-9]+$' THEN CAST(gn.val AS BIGINT) ELSE 0 END
    ) DESC NULLS LAST, gn.id
    LIMIT $1
), sel_node_ids AS MATERIALIZED (
    -- Explicitly materialize IDs for efficient hash lookups in EXISTS subqueries
    SELECT id FROM sel_nodes
), sel_links AS (
    SELECT gl.id, gl.source, gl.target
    FROM graph_links gl
    WHERE EXISTS (SELECT 1 FROM sel_node_ids WHERE id = gl.source)
      AND EXISTS (SELECT 1 FROM sel_node_ids WHERE id = gl.target)
    LIMIT $2
)
SELECT
        'node' AS data_type,
        n.id,
        n.name,
        CAST(n.val AS TEXT) AS val,
    n.type,
    n.pos_x,
    n.pos_y,
    n.pos_z,
        NULL AS source,
        NULL AS target
FROM sel_nodes n
UNION ALL
SELECT
        'link' AS data_type,
        CAST(l.id AS TEXT),
        NULL AS name,
        CAST(NULL AS TEXT) AS val,
        NULL AS type,
    NULL as pos_x,
    NULL as pos_y,
    NULL as pos_z,
        l.source,
        l.target
FROM sel_links l
ORDER BY data_type, id
`

type GetPrecalculatedGraphDataCappedAllParams struct {
	Limit   int32
	Limit_2 int32
}

type GetPrecalculatedGraphDataCappedAllRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     sql.NullString
	PosX     sql.NullFloat64
	PosY     sql.NullFloat64
	PosZ     sql.NullFloat64
	Source   interface{}
	Target   interface{}
}

// Optimized query with improved link filtering
// Uses EXISTS subqueries for better performance on large datasets
// Note: statement_timeout is enforced at application level via context timeout
func (q *Queries) GetPrecalculatedGraphDataCappedAll(ctx context.Context, arg GetPrecalculatedGraphDataCappedAllParams) ([]GetPrecalculatedGraphDataCappedAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrecalculatedGraphDataCappedAll, arg.Limit, arg.Limit_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrecalculatedGraphDataCappedAllRow
	for rows.Next() {
		var i GetPrecalculatedGraphDataCappedAllRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrecalculatedGraphDataCappedFiltered = `-- name: GetPrecalculatedGraphDataCappedFiltered :many
WITH sel_nodes AS (
    SELECT gn.id, gn.name, gn.val, gn.type, gn.pos_x, gn.pos_y, gn.pos_z
    FROM graph_nodes gn
    WHERE gn.type IS NOT NULL AND gn.type = ANY($1::text[])
    ORDER BY (
        CASE WHEN gn.val ~ '^[0-9]+$' THEN CAST(gn.val AS BIGINT) ELSE 0 END
    ) DESC NULLS LAST, gn.id
    LIMIT $2
), sel_node_ids AS MATERIALIZED (
    -- Explicitly materialize IDs for efficient hash lookups in EXISTS subqueries
    SELECT id FROM sel_nodes
), sel_links AS (
    SELECT gl.id, gl.source, gl.target
    FROM graph_links gl
    WHERE EXISTS (SELECT 1 FROM sel_node_ids WHERE id = gl.source)
      AND EXISTS (SELECT 1 FROM sel_node_ids WHERE id = gl.target)
    LIMIT $3
)
SELECT
        'node' AS data_type,
        n.id,
        n.name,
        CAST(n.val AS TEXT) AS val,
    n.type,
    n.pos_x,
    n.pos_y,
    n.pos_z,
        NULL AS source,
        NULL AS target
FROM sel_nodes n
UNION ALL
SELECT
        'link' AS data_type,
        CAST(l.id AS TEXT),
        NULL AS name,
        CAST(NULL AS TEXT) AS val,
        NULL AS type,
    NULL as pos_x,
    NULL as pos_y,
    NULL as pos_z,
        l.source,
        l.target
FROM sel_links l
ORDER BY data_type, id
`

type GetPrecalculatedGraphDataCappedFilteredParams struct {
	Column1 []string
	Limit   int32
	Limit_2 int32
}

type GetPrecalculatedGraphDataCappedFilteredRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     sql.NullString
	PosX     sql.NullFloat64
	PosY     sql.NullFloat64
	PosZ     sql.NullFloat64
	Source   interface{}
	Target   interface{}
}

// Optimized query with improved link filtering
// Uses EXISTS subqueries for better performance than IN subqueries
// Note: statement_timeout is enforced at application level via context timeout
func (q *Queries) GetPrecalculatedGraphDataCappedFiltered(ctx context.Context, arg GetPrecalculatedGraphDataCappedFilteredParams) ([]GetPrecalculatedGraphDataCappedFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrecalculatedGraphDataCappedFiltered, pq.Array(arg.Column1), arg.Limit, arg.Limit_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrecalculatedGraphDataCappedFilteredRow
	for rows.Next() {
		var i GetPrecalculatedGraphDataCappedFilteredRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrecalculatedGraphDataNoPos = `-- name: GetPrecalculatedGraphDataNoPos :many
SELECT
    'node' as data_type,
    id,
    name,
    CAST(val AS TEXT) as val,
    type,
    NULL as source,
    NULL as target
FROM graph_nodes
UNION ALL
SELECT
    'link' as data_type,
    CAST(id AS TEXT),
    NULL as name,
    CAST(NULL AS TEXT) as val,
    NULL as type,
    source,
    target
FROM graph_links
ORDER BY data_type, id
`

type GetPrecalculatedGraphDataNoPosRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     sql.NullString
	Source   interface{}
	Target   interface{}
}

func (q *Queries) GetPrecalculatedGraphDataNoPos(ctx context.Context) ([]GetPrecalculatedGraphDataNoPosRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrecalculatedGraphDataNoPos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrecalculatedGraphDataNoPosRow
	for rows.Next() {
		var i GetPrecalculatedGraphDataNoPosRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubredditOverlap = `-- name: GetSubredditOverlap :one
WITH user_activity AS (
    SELECT DISTINCT p.author_id
    FROM posts p
    WHERE p.subreddit_id = $1
    UNION
    SELECT DISTINCT c.author_id
    FROM comments c
    WHERE c.subreddit_id = $1
),
other_activity AS (
    SELECT DISTINCT p.author_id
    FROM posts p
    WHERE p.subreddit_id = $2
    UNION
    SELECT DISTINCT c.author_id
    FROM comments c
    WHERE c.subreddit_id = $2
)
SELECT COUNT(*)
FROM user_activity ua
JOIN other_activity oa ON ua.author_id = oa.author_id
`

type GetSubredditOverlapParams struct {
	SubredditID   int32
	SubredditID_2 int32
}

func (q *Queries) GetSubredditOverlap(ctx context.Context, arg GetSubredditOverlapParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSubredditOverlap, arg.SubredditID, arg.SubredditID_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserSubredditActivityCount = `-- name: GetUserSubredditActivityCount :one
SELECT (
    (SELECT COUNT(*) FROM posts p WHERE p.author_id = $1 AND p.subreddit_id = $2) +
    (SELECT COUNT(*) FROM comments c WHERE c.author_id = $1 AND c.subreddit_id = $2)
) as activity_count
`

type GetUserSubredditActivityCountParams struct {
	AuthorID    int32
	SubredditID int32
}

func (q *Queries) GetUserSubredditActivityCount(ctx context.Context, arg GetUserSubredditActivityCountParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserSubredditActivityCount, arg.AuthorID, arg.SubredditID)
	var activity_count int32
	err := row.Scan(&activity_count)
	return activity_count, err
}

const getUserSubreddits = `-- name: GetUserSubreddits :many
SELECT DISTINCT s.id, s.name
FROM subreddits s
JOIN posts p ON p.subreddit_id = s.id
WHERE p.author_id = $1
UNION
SELECT DISTINCT s.id, s.name
FROM subreddits s
JOIN comments c ON c.subreddit_id = s.id
WHERE c.author_id = $1
`

type GetUserSubredditsRow struct {
	ID   int32
	Name string
}

func (q *Queries) GetUserSubreddits(ctx context.Context, authorID int32) ([]GetUserSubredditsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSubreddits, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSubredditsRow
	for rows.Next() {
		var i GetUserSubredditsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTotalActivity = `-- name: GetUserTotalActivity :one
SELECT (
    (SELECT COUNT(*) FROM posts p WHERE p.author_id = $1) +
    (SELECT COUNT(*) FROM comments c WHERE c.author_id = $1)
) as total_activity
`

func (q *Queries) GetUserTotalActivity(ctx context.Context, authorID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserTotalActivity, authorID)
	var total_activity int32
	err := row.Scan(&total_activity)
	return total_activity, err
}

const insertCommunityHierarchy = `-- name: InsertCommunityHierarchy :exec
INSERT INTO graph_community_hierarchy (
    node_id,
    level,
    community_id,
    parent_community_id,
    centroid_x,
    centroid_y,
    centroid_z
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) ON CONFLICT (node_id, level) DO UPDATE SET
    community_id = EXCLUDED.community_id,
    parent_community_id = EXCLUDED.parent_community_id,
    centroid_x = EXCLUDED.centroid_x,
    centroid_y = EXCLUDED.centroid_y,
    centroid_z = EXCLUDED.centroid_z
`

type InsertCommunityHierarchyParams struct {
	NodeID            string
	Level             int32
	CommunityID       int32
	ParentCommunityID sql.NullInt32
	CentroidX         sql.NullFloat64
	CentroidY         sql.NullFloat64
	CentroidZ         sql.NullFloat64
}

func (q *Queries) InsertCommunityHierarchy(ctx context.Context, arg InsertCommunityHierarchyParams) error {
	_, err := q.db.ExecContext(ctx, insertCommunityHierarchy,
		arg.NodeID,
		arg.Level,
		arg.CommunityID,
		arg.ParentCommunityID,
		arg.CentroidX,
		arg.CentroidY,
		arg.CentroidZ,
	)
	return err
}

const listGraphLinksAmong = `-- name: ListGraphLinksAmong :many
SELECT source, target
FROM graph_links
WHERE source = ANY($1::text[]) AND target = ANY($1::text[])
`

type ListGraphLinksAmongRow struct {
	Source string
	Target string
}

func (q *Queries) ListGraphLinksAmong(ctx context.Context, dollar_1 []string) ([]ListGraphLinksAmongRow, error) {
	rows, err := q.db.QueryContext(ctx, listGraphLinksAmong, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGraphLinksAmongRow
	for rows.Next() {
		var i ListGraphLinksAmongRow
		if err := rows.Scan(&i.Source, &i.Target); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGraphNodesByWeight = `-- name: ListGraphNodesByWeight :many
SELECT id, name, val, type, pos_x, pos_y, pos_z
FROM graph_nodes gn
ORDER BY (
    CASE WHEN gn.val ~ '^[0-9]+$' THEN CAST(gn.val AS BIGINT) ELSE 0 END
) DESC NULLS LAST, gn.id
LIMIT $1
`

type ListGraphNodesByWeightRow struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

func (q *Queries) ListGraphNodesByWeight(ctx context.Context, limit int32) ([]ListGraphNodesByWeightRow, error) {
	rows, err := q.db.QueryContext(ctx, listGraphNodesByWeight, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGraphNodesByWeightRow
	for rows.Next() {
		var i ListGraphNodesByWeightRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithActivity = `-- name: ListUsersWithActivity :many
SELECT
    u.id,
    u.username,
    COALESCE(p.post_count, 0) + COALESCE(c.comment_count, 0) AS total_activity
FROM users u
LEFT JOIN (
    SELECT author_id, CAST(COUNT(*) AS BIGINT) AS post_count
    FROM posts
    GROUP BY author_id
) p ON p.author_id = u.id
LEFT JOIN (
    SELECT author_id, CAST(COUNT(*) AS BIGINT) AS comment_count
    FROM comments
    GROUP BY author_id
) c ON c.author_id = u.id
ORDER BY total_activity DESC, u.id
`

type ListUsersWithActivityRow struct {
	ID            int32
	Username      string
	TotalActivity int32
}

func (q *Queries) ListUsersWithActivity(ctx context.Context) ([]ListUsersWithActivityRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersWithActivity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersWithActivityRow
	for rows.Next() {
		var i ListUsersWithActivityRow
		if err := rows.Scan(&i.ID, &i.Username, &i.TotalActivity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGraphNodes = `-- name: SearchGraphNodes :many
SELECT 
    id,
    name,
    CAST(val AS TEXT) as val,
    type,
    pos_x,
    pos_y,
    pos_z
FROM graph_nodes
WHERE 
    name ILIKE '%' || $1 || '%' 
    OR id ILIKE '%' || $1 || '%'
ORDER BY 
    CASE 
        WHEN LOWER(name) = LOWER($1) THEN 0
        WHEN LOWER(id) = LOWER($1) THEN 1
        ELSE 2
    END,
    CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END DESC
LIMIT $2
`

type SearchGraphNodesParams struct {
	Column1 sql.NullString
	Limit   int32
}

type SearchGraphNodesRow struct {
	ID   string
	Name string
	Val  string
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

// Fuzzy search for graph nodes by name or ID
// Uses ILIKE for case-insensitive partial matching
// Orders results by exact match first, then by relevance (val/weight)
// Note: Leading wildcards prevent index usage and cause full table scans.
// For large datasets, consider adding a GIN or GiST index with pg_trgm extension.
func (q *Queries) SearchGraphNodes(ctx context.Context, arg SearchGraphNodesParams) ([]SearchGraphNodesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGraphNodes, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGraphNodesRow
	for rows.Next() {
		var i SearchGraphNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGraphNodePositions = `-- name: UpdateGraphNodePositions :exec
UPDATE graph_nodes g
SET pos_x = u.x, pos_y = u.y, pos_z = u.z, updated_at = now()
FROM (
    SELECT unnest($1::text[]) AS id,
           unnest($2::double precision[]) AS x,
           unnest($3::double precision[]) AS y,
           unnest($4::double precision[]) AS z
) AS u
WHERE g.id = u.id
`

type UpdateGraphNodePositionsParams struct {
	Column1 []string
	Column2 []float64
	Column3 []float64
	Column4 []float64
}

func (q *Queries) UpdateGraphNodePositions(ctx context.Context, arg UpdateGraphNodePositionsParams) error {
	_, err := q.db.ExecContext(ctx, updateGraphNodePositions,
		pq.Array(arg.Column1),
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
	)
	return err
}
