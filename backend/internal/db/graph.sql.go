// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: graph.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const bulkInsertGraphLink = `-- name: BulkInsertGraphLink :exec
INSERT INTO graph_links (source, target)
SELECT $1, $2
WHERE EXISTS (SELECT 1 FROM graph_nodes WHERE id = $1)
    AND EXISTS (SELECT 1 FROM graph_nodes WHERE id = $2)
ON CONFLICT (source, target) DO NOTHING
`

type BulkInsertGraphLinkParams struct {
	Source string
	Target string
}

func (q *Queries) BulkInsertGraphLink(ctx context.Context, arg BulkInsertGraphLinkParams) error {
	_, err := q.db.ExecContext(ctx, bulkInsertGraphLink, arg.Source, arg.Target)
	return err
}

const bulkInsertGraphNode = `-- name: BulkInsertGraphNode :exec
INSERT INTO graph_nodes (
    id,
    name,
    val,
    type
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (id) DO UPDATE
SET
    name = EXCLUDED.name,
    val = EXCLUDED.val,
    type = EXCLUDED.type,
    updated_at = now()
`

type BulkInsertGraphNodeParams struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
}

func (q *Queries) BulkInsertGraphNode(ctx context.Context, arg BulkInsertGraphNodeParams) error {
	_, err := q.db.ExecContext(ctx, bulkInsertGraphNode,
		arg.ID,
		arg.Name,
		arg.Val,
		arg.Type,
	)
	return err
}

const clearCommunityHierarchy = `-- name: ClearCommunityHierarchy :exec

TRUNCATE TABLE graph_community_hierarchy
`

// ============================================================
// Community Hierarchy Queries
// ============================================================
func (q *Queries) ClearCommunityHierarchy(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearCommunityHierarchy)
	return err
}

const clearCommunityTables = `-- name: ClearCommunityTables :exec

TRUNCATE TABLE graph_communities CASCADE
`

// ============================================================
// Community Detection Queries
// ============================================================
func (q *Queries) ClearCommunityTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearCommunityTables)
	return err
}

const clearEdgeBundles = `-- name: ClearEdgeBundles :exec

TRUNCATE TABLE graph_bundles
`

// ============================================================
// Edge Bundle Queries
// ============================================================
func (q *Queries) ClearEdgeBundles(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearEdgeBundles)
	return err
}

const clearGraphTables = `-- name: ClearGraphTables :exec
TRUNCATE TABLE graph_nodes, graph_links
`

func (q *Queries) ClearGraphTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearGraphTables)
	return err
}

const clearSubredditRelationships = `-- name: ClearSubredditRelationships :exec
TRUNCATE TABLE subreddit_relationships
`

func (q *Queries) ClearSubredditRelationships(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearSubredditRelationships)
	return err
}

const clearUserSubredditActivity = `-- name: ClearUserSubredditActivity :exec
TRUNCATE TABLE user_subreddit_activity
`

func (q *Queries) ClearUserSubredditActivity(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearUserSubredditActivity)
	return err
}

const countChangedEntities = `-- name: CountChangedEntities :one
SELECT 
    (SELECT COUNT(*) FROM subreddits s WHERE s.updated_at > $1 OR s.created_at > $1) as changed_subreddits,
    (SELECT COUNT(*) FROM users u WHERE u.updated_at > $1 OR u.created_at > $1) as changed_users,
    (SELECT COUNT(*) FROM posts p WHERE p.updated_at > $1) as changed_posts,
    (SELECT COUNT(*) FROM comments c WHERE c.updated_at > $1) as changed_comments
`

type CountChangedEntitiesRow struct {
	ChangedSubreddits int64
	ChangedUsers      int64
	ChangedPosts      int64
	ChangedComments   int64
}

// Count how many entities have changed since the given timestamp
func (q *Queries) CountChangedEntities(ctx context.Context, updatedAt sql.NullTime) (CountChangedEntitiesRow, error) {
	row := q.db.QueryRowContext(ctx, countChangedEntities, updatedAt)
	var i CountChangedEntitiesRow
	err := row.Scan(
		&i.ChangedSubreddits,
		&i.ChangedUsers,
		&i.ChangedPosts,
		&i.ChangedComments,
	)
	return i, err
}

const countGraphDiffsForVersion = `-- name: CountGraphDiffsForVersion :one
SELECT COUNT(*) FROM graph_diffs WHERE version_id = $1
`

// Count diffs for a specific version
func (q *Queries) CountGraphDiffsForVersion(ctx context.Context, versionID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGraphDiffsForVersion, versionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGraphVersions = `-- name: CountGraphVersions :one
SELECT COUNT(*) FROM graph_versions
`

// Count total number of graph versions
func (q *Queries) CountGraphVersions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGraphVersions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNodesInBoundingBox = `-- name: CountNodesInBoundingBox :one
SELECT COUNT(*)
FROM graph_nodes
WHERE pos_x IS NOT NULL
  AND pos_y IS NOT NULL
  AND pos_z IS NOT NULL
  AND pos_x BETWEEN $1 AND $2
  AND pos_y BETWEEN $3 AND $4
  AND pos_z BETWEEN $5 AND $6
`

type CountNodesInBoundingBoxParams struct {
	PosX   sql.NullFloat64
	PosX_2 sql.NullFloat64
	PosY   sql.NullFloat64
	PosY_2 sql.NullFloat64
	PosZ   sql.NullFloat64
	PosZ_2 sql.NullFloat64
}

// Count nodes within a bounding box (useful for pagination)
// Parameters: x_min, x_max, y_min, y_max, z_min, z_max
func (q *Queries) CountNodesInBoundingBox(ctx context.Context, arg CountNodesInBoundingBoxParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNodesInBoundingBox,
		arg.PosX,
		arg.PosX_2,
		arg.PosY,
		arg.PosY_2,
		arg.PosZ,
		arg.PosZ_2,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCommunity = `-- name: CreateCommunity :one
INSERT INTO graph_communities (
    label,
    size,
    modularity
) VALUES (
    $1, $2, $3
) RETURNING id, label, size, modularity, created_at, updated_at
`

type CreateCommunityParams struct {
	Label      string
	Size       int32
	Modularity sql.NullFloat64
}

func (q *Queries) CreateCommunity(ctx context.Context, arg CreateCommunityParams) (GraphCommunity, error) {
	row := q.db.QueryRowContext(ctx, createCommunity, arg.Label, arg.Size, arg.Modularity)
	var i GraphCommunity
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Size,
		&i.Modularity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCommunityLink = `-- name: CreateCommunityLink :exec
INSERT INTO graph_community_links (
    source_community_id,
    target_community_id,
    weight
) VALUES (
    $1, $2, $3
) ON CONFLICT (source_community_id, target_community_id)
DO UPDATE SET weight = EXCLUDED.weight, updated_at = now()
`

type CreateCommunityLinkParams struct {
	SourceCommunityID int32
	TargetCommunityID int32
	Weight            int32
}

func (q *Queries) CreateCommunityLink(ctx context.Context, arg CreateCommunityLinkParams) error {
	_, err := q.db.ExecContext(ctx, createCommunityLink, arg.SourceCommunityID, arg.TargetCommunityID, arg.Weight)
	return err
}

const createCommunityMember = `-- name: CreateCommunityMember :exec
INSERT INTO graph_community_members (
    community_id,
    node_id
) VALUES (
    $1, $2
) ON CONFLICT (community_id, node_id) DO NOTHING
`

type CreateCommunityMemberParams struct {
	CommunityID int32
	NodeID      string
}

func (q *Queries) CreateCommunityMember(ctx context.Context, arg CreateCommunityMemberParams) error {
	_, err := q.db.ExecContext(ctx, createCommunityMember, arg.CommunityID, arg.NodeID)
	return err
}

const createEdgeBundle = `-- name: CreateEdgeBundle :exec
INSERT INTO graph_bundles (
    source_community_id,
    target_community_id,
    weight,
    avg_strength,
    control_x,
    control_y,
    control_z
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) ON CONFLICT (source_community_id, target_community_id)
DO UPDATE SET 
    weight = EXCLUDED.weight,
    avg_strength = EXCLUDED.avg_strength,
    control_x = EXCLUDED.control_x,
    control_y = EXCLUDED.control_y,
    control_z = EXCLUDED.control_z,
    updated_at = now()
`

type CreateEdgeBundleParams struct {
	SourceCommunityID int32
	TargetCommunityID int32
	Weight            int32
	AvgStrength       sql.NullFloat64
	ControlX          sql.NullFloat64
	ControlY          sql.NullFloat64
	ControlZ          sql.NullFloat64
}

func (q *Queries) CreateEdgeBundle(ctx context.Context, arg CreateEdgeBundleParams) error {
	_, err := q.db.ExecContext(ctx, createEdgeBundle,
		arg.SourceCommunityID,
		arg.TargetCommunityID,
		arg.Weight,
		arg.AvgStrength,
		arg.ControlX,
		arg.ControlY,
		arg.ControlZ,
	)
	return err
}

const createGraphDiff = `-- name: CreateGraphDiff :exec
INSERT INTO graph_diffs (
    version_id,
    action,
    entity_type,
    entity_id,
    old_val,
    new_val,
    old_pos_x,
    old_pos_y,
    old_pos_z,
    new_pos_x,
    new_pos_y,
    new_pos_z
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
`

type CreateGraphDiffParams struct {
	VersionID  int64
	Action     string
	EntityType string
	EntityID   string
	OldVal     sql.NullString
	NewVal     sql.NullString
	OldPosX    sql.NullFloat64
	OldPosY    sql.NullFloat64
	OldPosZ    sql.NullFloat64
	NewPosX    sql.NullFloat64
	NewPosY    sql.NullFloat64
	NewPosZ    sql.NullFloat64
}

// Record a diff entry for a graph version
func (q *Queries) CreateGraphDiff(ctx context.Context, arg CreateGraphDiffParams) error {
	_, err := q.db.ExecContext(ctx, createGraphDiff,
		arg.VersionID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.OldVal,
		arg.NewVal,
		arg.OldPosX,
		arg.OldPosY,
		arg.OldPosZ,
		arg.NewPosX,
		arg.NewPosY,
		arg.NewPosZ,
	)
	return err
}

const createGraphLink = `-- name: CreateGraphLink :one
INSERT INTO graph_links (
    source,
    target
) VALUES (
    $1, $2
) RETURNING id, source, target, created_at, updated_at
`

type CreateGraphLinkParams struct {
	Source string
	Target string
}

func (q *Queries) CreateGraphLink(ctx context.Context, arg CreateGraphLinkParams) (GraphLink, error) {
	row := q.db.QueryRowContext(ctx, createGraphLink, arg.Source, arg.Target)
	var i GraphLink
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Target,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGraphVersion = `-- name: CreateGraphVersion :one

INSERT INTO graph_versions (
    node_count,
    link_count,
    status,
    precalc_duration_ms,
    is_full_rebuild
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, created_at, node_count, link_count, status, precalc_duration_ms, is_full_rebuild
`

type CreateGraphVersionParams struct {
	NodeCount         int32
	LinkCount         int32
	Status            string
	PrecalcDurationMs sql.NullInt32
	IsFullRebuild     bool
}

// ============================================================
// Graph Versioning Queries
// ============================================================
// Create a new graph version record
func (q *Queries) CreateGraphVersion(ctx context.Context, arg CreateGraphVersionParams) (GraphVersion, error) {
	row := q.db.QueryRowContext(ctx, createGraphVersion,
		arg.NodeCount,
		arg.LinkCount,
		arg.Status,
		arg.PrecalcDurationMs,
		arg.IsFullRebuild,
	)
	var i GraphVersion
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.NodeCount,
		&i.LinkCount,
		&i.Status,
		&i.PrecalcDurationMs,
		&i.IsFullRebuild,
	)
	return i, err
}

const createSubredditRelationship = `-- name: CreateSubredditRelationship :one
INSERT INTO subreddit_relationships (
    source_subreddit_id,
    target_subreddit_id,
    overlap_count
) VALUES (
    $1, $2, $3
) ON CONFLICT (source_subreddit_id, target_subreddit_id)
DO UPDATE SET
    overlap_count = EXCLUDED.overlap_count,
    updated_at = now()
RETURNING id, source_subreddit_id, target_subreddit_id, overlap_count, created_at, updated_at
`

type CreateSubredditRelationshipParams struct {
	SourceSubredditID int32
	TargetSubredditID int32
	OverlapCount      int32
}

func (q *Queries) CreateSubredditRelationship(ctx context.Context, arg CreateSubredditRelationshipParams) (SubredditRelationship, error) {
	row := q.db.QueryRowContext(ctx, createSubredditRelationship, arg.SourceSubredditID, arg.TargetSubredditID, arg.OverlapCount)
	var i SubredditRelationship
	err := row.Scan(
		&i.ID,
		&i.SourceSubredditID,
		&i.TargetSubredditID,
		&i.OverlapCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserSubredditActivity = `-- name: CreateUserSubredditActivity :one
INSERT INTO user_subreddit_activity (
    user_id,
    subreddit_id,
    activity_count
) VALUES (
    $1, $2, $3
) RETURNING id, user_id, subreddit_id, activity_count, created_at, updated_at
`

type CreateUserSubredditActivityParams struct {
	UserID        int32
	SubredditID   int32
	ActivityCount int32
}

func (q *Queries) CreateUserSubredditActivity(ctx context.Context, arg CreateUserSubredditActivityParams) (UserSubredditActivity, error) {
	row := q.db.QueryRowContext(ctx, createUserSubredditActivity, arg.UserID, arg.SubredditID, arg.ActivityCount)
	var i UserSubredditActivity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubredditID,
		&i.ActivityCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOldGraphVersions = `-- name: DeleteOldGraphVersions :exec
WITH versions_to_keep AS (
    SELECT id FROM graph_versions
    ORDER BY id DESC
    LIMIT $1
)
DELETE FROM graph_versions
WHERE id NOT IN (SELECT id FROM versions_to_keep)
`

// Delete graph versions older than the retention count
// Keeps the most recent N versions
func (q *Queries) DeleteOldGraphVersions(ctx context.Context, limit int32) error {
	_, err := q.db.ExecContext(ctx, deleteOldGraphVersions, limit)
	return err
}

const deleteOrphanedGraphLinks = `-- name: DeleteOrphanedGraphLinks :exec
DELETE FROM graph_links
WHERE source NOT IN (SELECT id FROM graph_nodes)
   OR target NOT IN (SELECT id FROM graph_nodes)
`

// Delete graph links where source or target nodes no longer exist
func (q *Queries) DeleteOrphanedGraphLinks(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOrphanedGraphLinks)
	return err
}

const deleteOrphanedGraphNodes = `-- name: DeleteOrphanedGraphNodes :exec
DELETE FROM graph_nodes
WHERE (type = 'user' AND id NOT IN (SELECT 'user_' || id::text FROM users))
   OR (type = 'subreddit' AND id NOT IN (SELECT 'subreddit_' || id::text FROM subreddits))
`

// Delete graph nodes that no longer have corresponding source entities
// This is used after incremental updates to clean up stale data
func (q *Queries) DeleteOrphanedGraphNodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOrphanedGraphNodes)
	return err
}

const getAffectedSubredditIDs = `-- name: GetAffectedSubredditIDs :many
WITH changed_subreddits AS (
    SELECT DISTINCT subreddit_id FROM posts WHERE posts.updated_at > $1
    UNION
    SELECT DISTINCT subreddit_id FROM comments WHERE comments.updated_at > $1
    UNION
    SELECT id as subreddit_id FROM subreddits WHERE subreddits.updated_at > $1 OR subreddits.created_at > $1
)
SELECT subreddit_id FROM changed_subreddits
ORDER BY subreddit_id
`

// Get subreddit IDs affected by changed posts/comments
func (q *Queries) GetAffectedSubredditIDs(ctx context.Context, updatedAt sql.NullTime) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAffectedSubredditIDs, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var subreddit_id int32
		if err := rows.Scan(&subreddit_id); err != nil {
			return nil, err
		}
		items = append(items, subreddit_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAffectedUserIDs = `-- name: GetAffectedUserIDs :many
WITH changed_authors AS (
    SELECT DISTINCT author_id FROM posts WHERE posts.updated_at > $1
    UNION
    SELECT DISTINCT author_id FROM comments WHERE comments.updated_at > $1
)
SELECT author_id FROM changed_authors
ORDER BY author_id
`

// Get user IDs affected by changed posts/comments
func (q *Queries) GetAffectedUserIDs(ctx context.Context, updatedAt sql.NullTime) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAffectedUserIDs, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var author_id int32
		if err := rows.Scan(&author_id); err != nil {
			return nil, err
		}
		items = append(items, author_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllComments = `-- name: GetAllComments :many
SELECT id, body, score, post_id
FROM comments
`

type GetAllCommentsRow struct {
	ID     string
	Body   sql.NullString
	Score  sql.NullInt32
	PostID string
}

func (q *Queries) GetAllComments(ctx context.Context) ([]GetAllCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllComments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCommentsRow
	for rows.Next() {
		var i GetAllCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.Score,
			&i.PostID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCommunities = `-- name: GetAllCommunities :many
SELECT id, label, size, modularity, created_at, updated_at FROM graph_communities
ORDER BY size DESC
`

func (q *Queries) GetAllCommunities(ctx context.Context) ([]GraphCommunity, error) {
	rows, err := q.db.QueryContext(ctx, getAllCommunities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GraphCommunity
	for rows.Next() {
		var i GraphCommunity
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Size,
			&i.Modularity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many
SELECT id, title, score
FROM posts
`

type GetAllPostsRow struct {
	ID    string
	Title sql.NullString
	Score sql.NullInt32
}

func (q *Queries) GetAllPosts(ctx context.Context) ([]GetAllPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPostsRow
	for rows.Next() {
		var i GetAllPostsRow
		if err := rows.Scan(&i.ID, &i.Title, &i.Score); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubredditRelationships = `-- name: GetAllSubredditRelationships :many
SELECT source_subreddit_id, target_subreddit_id, overlap_count
FROM subreddit_relationships
`

type GetAllSubredditRelationshipsRow struct {
	SourceSubredditID int32
	TargetSubredditID int32
	OverlapCount      int32
}

func (q *Queries) GetAllSubredditRelationships(ctx context.Context) ([]GetAllSubredditRelationshipsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubredditRelationships)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubredditRelationshipsRow
	for rows.Next() {
		var i GetAllSubredditRelationshipsRow
		if err := rows.Scan(&i.SourceSubredditID, &i.TargetSubredditID, &i.OverlapCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubreddits = `-- name: GetAllSubreddits :many
SELECT id, name, subscribers
FROM subreddits
`

type GetAllSubredditsRow struct {
	ID          int32
	Name        string
	Subscribers sql.NullInt32
}

func (q *Queries) GetAllSubreddits(ctx context.Context) ([]GetAllSubredditsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubreddits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubredditsRow
	for rows.Next() {
		var i GetAllSubredditsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Subscribers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserSubredditActivity = `-- name: GetAllUserSubredditActivity :many
SELECT user_id, subreddit_id, activity_count
FROM user_subreddit_activity
`

type GetAllUserSubredditActivityRow struct {
	UserID        int32
	SubredditID   int32
	ActivityCount int32
}

func (q *Queries) GetAllUserSubredditActivity(ctx context.Context) ([]GetAllUserSubredditActivityRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserSubredditActivity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserSubredditActivityRow
	for rows.Next() {
		var i GetAllUserSubredditActivityRow
		if err := rows.Scan(&i.UserID, &i.SubredditID, &i.ActivityCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, username
FROM users
`

type GetAllUsersRow struct {
	ID       int32
	Username string
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(&i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangedCommentsSince = `-- name: GetChangedCommentsSince :many
SELECT id, subreddit_id, author_id, post_id
FROM comments
WHERE updated_at > $1
ORDER BY id
`

type GetChangedCommentsSinceRow struct {
	ID          string
	SubredditID int32
	AuthorID    int32
	PostID      string
}

// Get comments that have been created or updated since the given timestamp
func (q *Queries) GetChangedCommentsSince(ctx context.Context, updatedAt sql.NullTime) ([]GetChangedCommentsSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getChangedCommentsSince, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangedCommentsSinceRow
	for rows.Next() {
		var i GetChangedCommentsSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.AuthorID,
			&i.PostID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangedPostsSince = `-- name: GetChangedPostsSince :many
SELECT id, subreddit_id, author_id
FROM posts
WHERE updated_at > $1
ORDER BY id
`

type GetChangedPostsSinceRow struct {
	ID          string
	SubredditID int32
	AuthorID    int32
}

// Get posts that have been created or updated since the given timestamp
func (q *Queries) GetChangedPostsSince(ctx context.Context, updatedAt sql.NullTime) ([]GetChangedPostsSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getChangedPostsSince, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangedPostsSinceRow
	for rows.Next() {
		var i GetChangedPostsSinceRow
		if err := rows.Scan(&i.ID, &i.SubredditID, &i.AuthorID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangedSubredditsSince = `-- name: GetChangedSubredditsSince :many
SELECT id, name, subscribers
FROM subreddits
WHERE updated_at > $1 OR created_at > $1
ORDER BY id
`

type GetChangedSubredditsSinceRow struct {
	ID          int32
	Name        string
	Subscribers sql.NullInt32
}

// Get subreddits that have been created or updated since the given timestamp
func (q *Queries) GetChangedSubredditsSince(ctx context.Context, updatedAt sql.NullTime) ([]GetChangedSubredditsSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getChangedSubredditsSince, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangedSubredditsSinceRow
	for rows.Next() {
		var i GetChangedSubredditsSinceRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Subscribers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangedUsersSince = `-- name: GetChangedUsersSince :many
SELECT id, username
FROM users
WHERE updated_at > $1 OR created_at > $1
ORDER BY id
`

type GetChangedUsersSinceRow struct {
	ID       int32
	Username string
}

// Get users that have been created or updated since the given timestamp
func (q *Queries) GetChangedUsersSince(ctx context.Context, updatedAt sql.NullTime) ([]GetChangedUsersSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getChangedUsersSince, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangedUsersSinceRow
	for rows.Next() {
		var i GetChangedUsersSinceRow
		if err := rows.Scan(&i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunitiesAtLevel = `-- name: GetCommunitiesAtLevel :many
SELECT 
    community_id,
    COUNT(*) as member_count,
    AVG(centroid_x) as avg_x,
    AVG(centroid_y) as avg_y,
    AVG(centroid_z) as avg_z
FROM graph_community_hierarchy
WHERE level = $1
GROUP BY community_id
ORDER BY member_count DESC
`

type GetCommunitiesAtLevelRow struct {
	CommunityID int32
	MemberCount int64
	AvgX        float64
	AvgY        float64
	AvgZ        float64
}

func (q *Queries) GetCommunitiesAtLevel(ctx context.Context, level int32) ([]GetCommunitiesAtLevelRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunitiesAtLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunitiesAtLevelRow
	for rows.Next() {
		var i GetCommunitiesAtLevelRow
		if err := rows.Scan(
			&i.CommunityID,
			&i.MemberCount,
			&i.AvgX,
			&i.AvgY,
			&i.AvgZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunity = `-- name: GetCommunity :one
SELECT id, label, size, modularity, created_at, updated_at FROM graph_communities
WHERE id = $1
`

func (q *Queries) GetCommunity(ctx context.Context, id int32) (GraphCommunity, error) {
	row := q.db.QueryRowContext(ctx, getCommunity, id)
	var i GraphCommunity
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Size,
		&i.Modularity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCommunityHierarchy = `-- name: GetCommunityHierarchy :many
SELECT 
    node_id,
    level,
    community_id,
    parent_community_id,
    centroid_x,
    centroid_y,
    centroid_z
FROM graph_community_hierarchy
ORDER BY level, community_id, node_id
`

type GetCommunityHierarchyRow struct {
	NodeID            string
	Level             int32
	CommunityID       int32
	ParentCommunityID sql.NullInt32
	CentroidX         sql.NullFloat64
	CentroidY         sql.NullFloat64
	CentroidZ         sql.NullFloat64
}

func (q *Queries) GetCommunityHierarchy(ctx context.Context) ([]GetCommunityHierarchyRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityHierarchy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunityHierarchyRow
	for rows.Next() {
		var i GetCommunityHierarchyRow
		if err := rows.Scan(
			&i.NodeID,
			&i.Level,
			&i.CommunityID,
			&i.ParentCommunityID,
			&i.CentroidX,
			&i.CentroidY,
			&i.CentroidZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityLinks = `-- name: GetCommunityLinks :many
SELECT
    'link' as data_type,
    CAST(gcl.source_community_id || '_' || gcl.target_community_id AS TEXT) as id,
    NULL as name,
    CAST(gcl.weight AS TEXT) as val,
    NULL as type,
    NULL as pos_x,
    NULL as pos_y,
    NULL as pos_z,
    CAST('community_' || gcl.source_community_id AS TEXT) as source,
    CAST('community_' || gcl.target_community_id AS TEXT) as target
FROM graph_community_links gcl
ORDER BY gcl.weight DESC
LIMIT $1
`

type GetCommunityLinksRow struct {
	DataType string
	ID       string
	Name     interface{}
	Val      string
	Type     interface{}
	PosX     interface{}
	PosY     interface{}
	PosZ     interface{}
	Source   string
	Target   string
}

func (q *Queries) GetCommunityLinks(ctx context.Context, limit int32) ([]GetCommunityLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityLinks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunityLinksRow
	for rows.Next() {
		var i GetCommunityLinksRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityMembers = `-- name: GetCommunityMembers :many
SELECT node_id FROM graph_community_members
WHERE community_id = $1
`

func (q *Queries) GetCommunityMembers(ctx context.Context, communityID int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityMembers, communityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var node_id string
		if err := rows.Scan(&node_id); err != nil {
			return nil, err
		}
		items = append(items, node_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunitySubgraph = `-- name: GetCommunitySubgraph :many
WITH member_nodes AS (
    SELECT node_id FROM graph_community_members
    WHERE community_id = $1
)
SELECT
    'node' as data_type,
    gn.id,
    gn.name,
    CAST(gn.val AS TEXT) as val,
    gn.type,
    gn.pos_x,
    gn.pos_y,
    gn.pos_z,
    NULL as source,
    NULL as target
FROM graph_nodes gn
WHERE gn.id IN (SELECT node_id FROM member_nodes)
UNION ALL
SELECT
    'link' as data_type,
    CAST(gl.id AS TEXT),
    NULL as name,
    CAST(NULL AS TEXT) as val,
    NULL as type,
    NULL as pos_x,
    NULL as pos_y,
    NULL as pos_z,
    gl.source,
    gl.target
FROM graph_links gl
WHERE gl.source IN (SELECT node_id FROM member_nodes)
    AND gl.target IN (SELECT node_id FROM member_nodes)
ORDER BY data_type, id
LIMIT $2
`

type GetCommunitySubgraphParams struct {
	CommunityID int32
	Limit       int32
}

type GetCommunitySubgraphRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     sql.NullString
	PosX     sql.NullFloat64
	PosY     sql.NullFloat64
	PosZ     sql.NullFloat64
	Source   interface{}
	Target   interface{}
}

func (q *Queries) GetCommunitySubgraph(ctx context.Context, arg GetCommunitySubgraphParams) ([]GetCommunitySubgraphRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunitySubgraph, arg.CommunityID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunitySubgraphRow
	for rows.Next() {
		var i GetCommunitySubgraphRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunitySupernodesWithPositions = `-- name: GetCommunitySupernodesWithPositions :many
WITH community_stats AS (
    SELECT 
        gc.id,
        gc.label,
        gc.size,
        gc.modularity,
        COALESCE(AVG(gn.pos_x), 0) as avg_x,
        COALESCE(AVG(gn.pos_y), 0) as avg_y,
        COALESCE(AVG(gn.pos_z), 0) as avg_z
    FROM graph_communities gc
    LEFT JOIN graph_community_members gcm ON gc.id = gcm.community_id
    LEFT JOIN graph_nodes gn ON gcm.node_id = gn.id
    GROUP BY gc.id, gc.label, gc.size, gc.modularity
)
SELECT 
    'node' as data_type,
    CAST('community_' || id AS TEXT) as id,
    label as name,
    CAST(size AS TEXT) as val,
    'community' as type,
    avg_x as pos_x,
    avg_y as pos_y,
    avg_z as pos_z,
    NULL as source,
    NULL as target
FROM community_stats
ORDER BY size DESC
`

type GetCommunitySupernodesWithPositionsRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     string
	PosX     interface{}
	PosY     interface{}
	PosZ     interface{}
	Source   interface{}
	Target   interface{}
}

func (q *Queries) GetCommunitySupernodesWithPositions(ctx context.Context) ([]GetCommunitySupernodesWithPositionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunitySupernodesWithPositions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunitySupernodesWithPositionsRow
	for rows.Next() {
		var i GetCommunitySupernodesWithPositionsRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentGraphVersion = `-- name: GetCurrentGraphVersion :one
SELECT id, created_at, node_count, link_count, status, precalc_duration_ms, is_full_rebuild FROM graph_versions 
WHERE status = 'completed'
ORDER BY id DESC 
LIMIT 1
`

// Get the most recent completed graph version
func (q *Queries) GetCurrentGraphVersion(ctx context.Context) (GraphVersion, error) {
	row := q.db.QueryRowContext(ctx, getCurrentGraphVersion)
	var i GraphVersion
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.NodeCount,
		&i.LinkCount,
		&i.Status,
		&i.PrecalcDurationMs,
		&i.IsFullRebuild,
	)
	return i, err
}

const getEdgeBundles = `-- name: GetEdgeBundles :many
SELECT
    source_community_id,
    target_community_id,
    weight,
    avg_strength,
    control_x,
    control_y,
    control_z
FROM graph_bundles
WHERE weight >= $1
ORDER BY weight DESC
`

type GetEdgeBundlesRow struct {
	SourceCommunityID int32
	TargetCommunityID int32
	Weight            int32
	AvgStrength       sql.NullFloat64
	ControlX          sql.NullFloat64
	ControlY          sql.NullFloat64
	ControlZ          sql.NullFloat64
}

func (q *Queries) GetEdgeBundles(ctx context.Context, weight int32) ([]GetEdgeBundlesRow, error) {
	rows, err := q.db.QueryContext(ctx, getEdgeBundles, weight)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEdgeBundlesRow
	for rows.Next() {
		var i GetEdgeBundlesRow
		if err := rows.Scan(
			&i.SourceCommunityID,
			&i.TargetCommunityID,
			&i.Weight,
			&i.AvgStrength,
			&i.ControlX,
			&i.ControlY,
			&i.ControlZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphDiffsForVersion = `-- name: GetGraphDiffsForVersion :many
SELECT id, version_id, action, entity_type, entity_id, old_val, new_val, old_pos_x, old_pos_y, old_pos_z, new_pos_x, new_pos_y, new_pos_z, created_at FROM graph_diffs
WHERE version_id = $1
ORDER BY id
`

// Get all diffs for a specific version
func (q *Queries) GetGraphDiffsForVersion(ctx context.Context, versionID int64) ([]GraphDiff, error) {
	rows, err := q.db.QueryContext(ctx, getGraphDiffsForVersion, versionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GraphDiff
	for rows.Next() {
		var i GraphDiff
		if err := rows.Scan(
			&i.ID,
			&i.VersionID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldVal,
			&i.NewVal,
			&i.OldPosX,
			&i.OldPosY,
			&i.OldPosZ,
			&i.NewPosX,
			&i.NewPosY,
			&i.NewPosZ,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphDiffsSinceVersion = `-- name: GetGraphDiffsSinceVersion :many
SELECT 
    gd.id,
    gd.version_id,
    gd.action,
    gd.entity_type,
    gd.entity_id,
    gd.old_val,
    gd.new_val,
    gd.old_pos_x,
    gd.old_pos_y,
    gd.old_pos_z,
    gd.new_pos_x,
    gd.new_pos_y,
    gd.new_pos_z,
    gd.created_at,
    gv.id as version_number
FROM graph_diffs gd
JOIN graph_versions gv ON gd.version_id = gv.id
WHERE gd.version_id > $1
  AND gv.status = 'completed'
ORDER BY gd.version_id, gd.id
`

type GetGraphDiffsSinceVersionRow struct {
	ID            int64
	VersionID     int64
	Action        string
	EntityType    string
	EntityID      string
	OldVal        sql.NullString
	NewVal        sql.NullString
	OldPosX       sql.NullFloat64
	OldPosY       sql.NullFloat64
	OldPosZ       sql.NullFloat64
	NewPosX       sql.NullFloat64
	NewPosY       sql.NullFloat64
	NewPosZ       sql.NullFloat64
	CreatedAt     time.Time
	VersionNumber int64
}

// Get all diffs since a specific version (exclusive)
// Returns changes from versions > $1 up to current
func (q *Queries) GetGraphDiffsSinceVersion(ctx context.Context, versionID int64) ([]GetGraphDiffsSinceVersionRow, error) {
	rows, err := q.db.QueryContext(ctx, getGraphDiffsSinceVersion, versionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGraphDiffsSinceVersionRow
	for rows.Next() {
		var i GetGraphDiffsSinceVersionRow
		if err := rows.Scan(
			&i.ID,
			&i.VersionID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldVal,
			&i.NewVal,
			&i.OldPosX,
			&i.OldPosY,
			&i.OldPosZ,
			&i.NewPosX,
			&i.NewPosY,
			&i.NewPosZ,
			&i.CreatedAt,
			&i.VersionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphVersion = `-- name: GetGraphVersion :one
SELECT id, created_at, node_count, link_count, status, precalc_duration_ms, is_full_rebuild FROM graph_versions WHERE id = $1
`

// Get a specific graph version by ID
func (q *Queries) GetGraphVersion(ctx context.Context, id int64) (GraphVersion, error) {
	row := q.db.QueryRowContext(ctx, getGraphVersion, id)
	var i GraphVersion
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.NodeCount,
		&i.LinkCount,
		&i.Status,
		&i.PrecalcDurationMs,
		&i.IsFullRebuild,
	)
	return i, err
}

const getHierarchyLevels = `-- name: GetHierarchyLevels :many
SELECT DISTINCT level
FROM graph_community_hierarchy
ORDER BY level
`

func (q *Queries) GetHierarchyLevels(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getHierarchyLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var level int32
		if err := rows.Scan(&level); err != nil {
			return nil, err
		}
		items = append(items, level)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinksForNodesInBoundingBox = `-- name: GetLinksForNodesInBoundingBox :many
WITH bbox_nodes AS (
    SELECT id
    FROM graph_nodes
    WHERE pos_x IS NOT NULL
      AND pos_y IS NOT NULL
      AND pos_z IS NOT NULL
      AND pos_x BETWEEN $1 AND $2
      AND pos_y BETWEEN $3 AND $4
      AND pos_z BETWEEN $5 AND $6
)
SELECT 
    gl.id,
    gl.source,
    gl.target
FROM graph_links gl
WHERE EXISTS (SELECT 1 FROM bbox_nodes WHERE id = gl.source)
  AND EXISTS (SELECT 1 FROM bbox_nodes WHERE id = gl.target)
LIMIT $7
`

type GetLinksForNodesInBoundingBoxParams struct {
	PosX   sql.NullFloat64
	PosX_2 sql.NullFloat64
	PosY   sql.NullFloat64
	PosY_2 sql.NullFloat64
	PosZ   sql.NullFloat64
	PosZ_2 sql.NullFloat64
	Limit  int32
}

type GetLinksForNodesInBoundingBoxRow struct {
	ID     int32
	Source string
	Target string
}

// Retrieves links where both source and target nodes are within the bounding box
// Uses the same spatial filtering approach
// Parameters: x_min, x_max, y_min, y_max, z_min, z_max, limit
func (q *Queries) GetLinksForNodesInBoundingBox(ctx context.Context, arg GetLinksForNodesInBoundingBoxParams) ([]GetLinksForNodesInBoundingBoxRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinksForNodesInBoundingBox,
		arg.PosX,
		arg.PosX_2,
		arg.PosY,
		arg.PosY_2,
		arg.PosZ,
		arg.PosZ_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksForNodesInBoundingBoxRow
	for rows.Next() {
		var i GetLinksForNodesInBoundingBoxRow
		if err := rows.Scan(&i.ID, &i.Source, &i.Target); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinksForPaginatedNodes = `-- name: GetLinksForPaginatedNodes :many
SELECT 
    id,
    source,
    target
FROM graph_links
WHERE source = ANY($1::text[]) 
  AND target = ANY($1::text[])
LIMIT $2
`

type GetLinksForPaginatedNodesParams struct {
	Column1 []string
	Limit   int32
}

type GetLinksForPaginatedNodesRow struct {
	ID     int32
	Source string
	Target string
}

// Get links where both source and target are in the provided node ID list
// Parameters: $1=node_ids (text array)
func (q *Queries) GetLinksForPaginatedNodes(ctx context.Context, arg GetLinksForPaginatedNodesParams) ([]GetLinksForPaginatedNodesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinksForPaginatedNodes, pq.Array(arg.Column1), arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksForPaginatedNodesRow
	for rows.Next() {
		var i GetLinksForPaginatedNodesRow
		if err := rows.Scan(&i.ID, &i.Source, &i.Target); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeDetails = `-- name: GetNodeDetails :one

SELECT 
    id,
    name,
    COALESCE(CAST(val AS TEXT), '') as val,
    type,
    pos_x,
    pos_y,
    pos_z
FROM graph_nodes
WHERE id = $1
`

type GetNodeDetailsRow struct {
	ID   string
	Name string
	Val  interface{}
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

// ============================================================
// Node Inspector Queries
// ============================================================
// Get detailed information about a specific node
func (q *Queries) GetNodeDetails(ctx context.Context, id string) (GetNodeDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getNodeDetails, id)
	var i GetNodeDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Val,
		&i.Type,
		&i.PosX,
		&i.PosY,
		&i.PosZ,
	)
	return i, err
}

const getNodeNeighbors = `-- name: GetNodeNeighbors :many
WITH node_links AS (
    SELECT gl.target as neighbor_id
    FROM graph_links gl
    WHERE gl.source = $1
    UNION ALL
    SELECT gl.source as neighbor_id
    FROM graph_links gl
    WHERE gl.target = $1
),
neighbor_degrees AS (
    SELECT 
        nl.neighbor_id,
        COUNT(*) as link_count
    FROM node_links nl
    GROUP BY nl.neighbor_id
)
SELECT 
    gn.id,
    gn.name,
    COALESCE(CAST(gn.val AS TEXT), '') as val,
    gn.type,
    nd.link_count::INTEGER as degree
FROM neighbor_degrees nd
JOIN graph_nodes gn ON gn.id = nd.neighbor_id
ORDER BY nd.link_count DESC, gn.id
LIMIT $2
`

type GetNodeNeighborsParams struct {
	Source string
	Limit  int32
}

type GetNodeNeighborsRow struct {
	ID     string
	Name   string
	Val    interface{}
	Type   sql.NullString
	Degree int32
}

// Get neighbors of a node with connection information
// Returns top N neighbors ordered by degree (treating all links as equal weight)
func (q *Queries) GetNodeNeighbors(ctx context.Context, arg GetNodeNeighborsParams) ([]GetNodeNeighborsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodeNeighbors, arg.Source, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodeNeighborsRow
	for rows.Next() {
		var i GetNodeNeighborsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.Degree,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesAtLevel = `-- name: GetNodesAtLevel :many
SELECT 
    node_id,
    community_id,
    parent_community_id,
    centroid_x,
    centroid_y,
    centroid_z
FROM graph_community_hierarchy
WHERE level = $1
ORDER BY community_id, node_id
`

type GetNodesAtLevelRow struct {
	NodeID            string
	CommunityID       int32
	ParentCommunityID sql.NullInt32
	CentroidX         sql.NullFloat64
	CentroidY         sql.NullFloat64
	CentroidZ         sql.NullFloat64
}

func (q *Queries) GetNodesAtLevel(ctx context.Context, level int32) ([]GetNodesAtLevelRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodesAtLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodesAtLevelRow
	for rows.Next() {
		var i GetNodesAtLevelRow
		if err := rows.Scan(
			&i.NodeID,
			&i.CommunityID,
			&i.ParentCommunityID,
			&i.CentroidX,
			&i.CentroidY,
			&i.CentroidZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesInBoundingBox = `-- name: GetNodesInBoundingBox :many
SELECT 
    id,
    name,
    val,
    type,
    pos_x,
    pos_y,
    pos_z
FROM graph_nodes
WHERE pos_x IS NOT NULL
  AND pos_y IS NOT NULL
  AND pos_z IS NOT NULL
  AND pos_x BETWEEN $1 AND $2
  AND pos_y BETWEEN $3 AND $4
  AND pos_z BETWEEN $5 AND $6
ORDER BY (
    CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END
) DESC NULLS LAST, id
LIMIT $7
`

type GetNodesInBoundingBoxParams struct {
	PosX   sql.NullFloat64
	PosX_2 sql.NullFloat64
	PosY   sql.NullFloat64
	PosY_2 sql.NullFloat64
	PosZ   sql.NullFloat64
	PosZ_2 sql.NullFloat64
	Limit  int32
}

type GetNodesInBoundingBoxRow struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

// Retrieves nodes within a 3D bounding box using the spatial index
// Parameters: x_min, x_max, y_min, y_max, z_min, z_max, limit
// The spatial index (idx_graph_nodes_spatial_nonnull) makes this query efficient
func (q *Queries) GetNodesInBoundingBox(ctx context.Context, arg GetNodesInBoundingBoxParams) ([]GetNodesInBoundingBoxRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodesInBoundingBox,
		arg.PosX,
		arg.PosX_2,
		arg.PosY,
		arg.PosY_2,
		arg.PosZ,
		arg.PosZ_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodesInBoundingBoxRow
	for rows.Next() {
		var i GetNodesInBoundingBoxRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesInBoundingBox2D = `-- name: GetNodesInBoundingBox2D :many
SELECT 
    id,
    name,
    val,
    type,
    pos_x,
    pos_y,
    pos_z
FROM graph_nodes
WHERE pos_x IS NOT NULL
  AND pos_y IS NOT NULL
  AND pos_z IS NOT NULL
  AND pos_x BETWEEN $1 AND $2
  AND pos_y BETWEEN $3 AND $4
ORDER BY (
    CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END
) DESC NULLS LAST, id
LIMIT $5
`

type GetNodesInBoundingBox2DParams struct {
	PosX   sql.NullFloat64
	PosX_2 sql.NullFloat64
	PosY   sql.NullFloat64
	PosY_2 sql.NullFloat64
	Limit  int32
}

type GetNodesInBoundingBox2DRow struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

// Retrieves nodes within a 2D bounding box (ignoring z coordinate)
// Parameters: x_min, x_max, y_min, y_max, limit
// Useful for 2D viewport queries where z is not relevant
// Note: Includes pos_z IS NOT NULL to match the partial GiST index predicate (which requires all position columns to be non-null)
func (q *Queries) GetNodesInBoundingBox2D(ctx context.Context, arg GetNodesInBoundingBox2DParams) ([]GetNodesInBoundingBox2DRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodesInBoundingBox2D,
		arg.PosX,
		arg.PosX_2,
		arg.PosY,
		arg.PosY_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodesInBoundingBox2DRow
	for rows.Next() {
		var i GetNodesInBoundingBox2DRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedGraphNodes = `-- name: GetPaginatedGraphNodes :many

SELECT 
    id,
    name,
    val,
    type,
    pos_x,
    pos_y,
    pos_z
FROM graph_nodes
WHERE 
    -- If no cursor, get from start; otherwise use cursor for pagination
    CASE 
        WHEN $1::BIGINT IS NULL THEN TRUE
        ELSE (
            -- Primary sort: weight descending
            (CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END) < $1::BIGINT
            OR (
                -- Tie-breaker: same weight, but ID is greater (for consistent ordering)
                (CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END) = $1::BIGINT
                AND id > $2::TEXT
            )
        )
    END
ORDER BY (
    CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END
) DESC NULLS LAST, id
LIMIT $3
`

type GetPaginatedGraphNodesParams struct {
	Column1 int64
	Column2 string
	Limit   int32
}

type GetPaginatedGraphNodesRow struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

// ============================================================
// Pagination Queries
// ============================================================
// Cursor-based pagination for graph nodes ordered by weight (val) descending
// Cursor format: "weight:id" for tie-breaking
// Parameters: $1=cursor_weight (BIGINT), $2=cursor_id (TEXT), $3=page_size (INT)
// If cursor_weight is NULL, starts from beginning
func (q *Queries) GetPaginatedGraphNodes(ctx context.Context, arg GetPaginatedGraphNodesParams) ([]GetPaginatedGraphNodesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPaginatedGraphNodes, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedGraphNodesRow
	for rows.Next() {
		var i GetPaginatedGraphNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrecalcState = `-- name: GetPrecalcState :one

SELECT id, last_precalc_at, last_full_precalc_at, total_nodes, total_links, precalc_duration_ms, current_version_id, created_at, updated_at FROM precalc_state WHERE id = 1
`

// ============================================================
// Incremental Precalculation Queries
// ============================================================
// Get the current precalculation state
func (q *Queries) GetPrecalcState(ctx context.Context) (PrecalcState, error) {
	row := q.db.QueryRowContext(ctx, getPrecalcState)
	var i PrecalcState
	err := row.Scan(
		&i.ID,
		&i.LastPrecalcAt,
		&i.LastFullPrecalcAt,
		&i.TotalNodes,
		&i.TotalLinks,
		&i.PrecalcDurationMs,
		&i.CurrentVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPrecalculatedGraphDataCappedAll = `-- name: GetPrecalculatedGraphDataCappedAll :many
WITH sel_nodes AS (
    SELECT gn.id, gn.name, gn.val, gn.type, gn.pos_x, gn.pos_y, gn.pos_z
    FROM graph_nodes gn
    ORDER BY (
        CASE WHEN gn.val ~ '^[0-9]+$' THEN CAST(gn.val AS BIGINT) ELSE 0 END
    ) DESC NULLS LAST, gn.id
    LIMIT $1
), sel_node_ids AS MATERIALIZED (
    -- Explicitly materialize IDs for efficient hash lookups in EXISTS subqueries
    SELECT id FROM sel_nodes
), sel_links AS (
    SELECT gl.id, gl.source, gl.target
    FROM graph_links gl
    WHERE EXISTS (SELECT 1 FROM sel_node_ids WHERE id = gl.source)
      AND EXISTS (SELECT 1 FROM sel_node_ids WHERE id = gl.target)
    LIMIT $2
)
SELECT
        'node' AS data_type,
        n.id,
        n.name,
        CAST(n.val AS TEXT) AS val,
    n.type,
    n.pos_x,
    n.pos_y,
    n.pos_z,
        NULL AS source,
        NULL AS target
FROM sel_nodes n
UNION ALL
SELECT
        'link' AS data_type,
        CAST(l.id AS TEXT),
        NULL AS name,
        CAST(NULL AS TEXT) AS val,
        NULL AS type,
    NULL as pos_x,
    NULL as pos_y,
    NULL as pos_z,
        l.source,
        l.target
FROM sel_links l
ORDER BY data_type, id
`

type GetPrecalculatedGraphDataCappedAllParams struct {
	Limit   int32
	Limit_2 int32
}

type GetPrecalculatedGraphDataCappedAllRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     sql.NullString
	PosX     sql.NullFloat64
	PosY     sql.NullFloat64
	PosZ     sql.NullFloat64
	Source   interface{}
	Target   interface{}
}

// Optimized query with improved link filtering
// Uses EXISTS subqueries for better performance on large datasets
// Note: statement_timeout is enforced at application level via context timeout
func (q *Queries) GetPrecalculatedGraphDataCappedAll(ctx context.Context, arg GetPrecalculatedGraphDataCappedAllParams) ([]GetPrecalculatedGraphDataCappedAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrecalculatedGraphDataCappedAll, arg.Limit, arg.Limit_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrecalculatedGraphDataCappedAllRow
	for rows.Next() {
		var i GetPrecalculatedGraphDataCappedAllRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrecalculatedGraphDataCappedFiltered = `-- name: GetPrecalculatedGraphDataCappedFiltered :many
WITH sel_nodes AS (
    SELECT gn.id, gn.name, gn.val, gn.type, gn.pos_x, gn.pos_y, gn.pos_z
    FROM graph_nodes gn
    WHERE gn.type IS NOT NULL AND gn.type = ANY($1::text[])
    ORDER BY (
        CASE WHEN gn.val ~ '^[0-9]+$' THEN CAST(gn.val AS BIGINT) ELSE 0 END
    ) DESC NULLS LAST, gn.id
    LIMIT $2
), sel_node_ids AS MATERIALIZED (
    -- Explicitly materialize IDs for efficient hash lookups in EXISTS subqueries
    SELECT id FROM sel_nodes
), sel_links AS (
    SELECT gl.id, gl.source, gl.target
    FROM graph_links gl
    WHERE EXISTS (SELECT 1 FROM sel_node_ids WHERE id = gl.source)
      AND EXISTS (SELECT 1 FROM sel_node_ids WHERE id = gl.target)
    LIMIT $3
)
SELECT
        'node' AS data_type,
        n.id,
        n.name,
        CAST(n.val AS TEXT) AS val,
    n.type,
    n.pos_x,
    n.pos_y,
    n.pos_z,
        NULL AS source,
        NULL AS target
FROM sel_nodes n
UNION ALL
SELECT
        'link' AS data_type,
        CAST(l.id AS TEXT),
        NULL AS name,
        CAST(NULL AS TEXT) AS val,
        NULL AS type,
    NULL as pos_x,
    NULL as pos_y,
    NULL as pos_z,
        l.source,
        l.target
FROM sel_links l
ORDER BY data_type, id
`

type GetPrecalculatedGraphDataCappedFilteredParams struct {
	Column1 []string
	Limit   int32
	Limit_2 int32
}

type GetPrecalculatedGraphDataCappedFilteredRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     sql.NullString
	PosX     sql.NullFloat64
	PosY     sql.NullFloat64
	PosZ     sql.NullFloat64
	Source   interface{}
	Target   interface{}
}

// Optimized query with improved link filtering
// Uses EXISTS subqueries for better performance than IN subqueries
// Note: statement_timeout is enforced at application level via context timeout
func (q *Queries) GetPrecalculatedGraphDataCappedFiltered(ctx context.Context, arg GetPrecalculatedGraphDataCappedFilteredParams) ([]GetPrecalculatedGraphDataCappedFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrecalculatedGraphDataCappedFiltered, pq.Array(arg.Column1), arg.Limit, arg.Limit_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrecalculatedGraphDataCappedFilteredRow
	for rows.Next() {
		var i GetPrecalculatedGraphDataCappedFilteredRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrecalculatedGraphDataNoPos = `-- name: GetPrecalculatedGraphDataNoPos :many
SELECT
    'node' as data_type,
    id,
    name,
    CAST(val AS TEXT) as val,
    type,
    NULL as source,
    NULL as target
FROM graph_nodes
UNION ALL
SELECT
    'link' as data_type,
    CAST(id AS TEXT),
    NULL as name,
    CAST(NULL AS TEXT) as val,
    NULL as type,
    source,
    target
FROM graph_links
ORDER BY data_type, id
`

type GetPrecalculatedGraphDataNoPosRow struct {
	DataType string
	ID       string
	Name     string
	Val      string
	Type     sql.NullString
	Source   interface{}
	Target   interface{}
}

func (q *Queries) GetPrecalculatedGraphDataNoPos(ctx context.Context) ([]GetPrecalculatedGraphDataNoPosRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrecalculatedGraphDataNoPos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrecalculatedGraphDataNoPosRow
	for rows.Next() {
		var i GetPrecalculatedGraphDataNoPosRow
		if err := rows.Scan(
			&i.DataType,
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.Source,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubredditOverlap = `-- name: GetSubredditOverlap :one
WITH user_activity AS (
    SELECT DISTINCT p.author_id
    FROM posts p
    WHERE p.subreddit_id = $1
    UNION
    SELECT DISTINCT c.author_id
    FROM comments c
    WHERE c.subreddit_id = $1
),
other_activity AS (
    SELECT DISTINCT p.author_id
    FROM posts p
    WHERE p.subreddit_id = $2
    UNION
    SELECT DISTINCT c.author_id
    FROM comments c
    WHERE c.subreddit_id = $2
)
SELECT COUNT(*)
FROM user_activity ua
JOIN other_activity oa ON ua.author_id = oa.author_id
`

type GetSubredditOverlapParams struct {
	SubredditID   int32
	SubredditID_2 int32
}

func (q *Queries) GetSubredditOverlap(ctx context.Context, arg GetSubredditOverlapParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSubredditOverlap, arg.SubredditID, arg.SubredditID_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserActivitySince = `-- name: GetUserActivitySince :many
SELECT DISTINCT
    u.id,
    u.username,
    COALESCE(p.post_count, 0) + COALESCE(c.comment_count, 0) AS total_activity
FROM users u
LEFT JOIN (
    SELECT author_id, CAST(COUNT(*) AS BIGINT) AS post_count
    FROM posts
    WHERE posts.updated_at > $1
    GROUP BY author_id
) p ON p.author_id = u.id
LEFT JOIN (
    SELECT author_id, CAST(COUNT(*) AS BIGINT) AS comment_count
    FROM comments
    WHERE comments.updated_at > $1
    GROUP BY author_id
) c ON c.author_id = u.id
WHERE (p.post_count IS NOT NULL AND p.post_count > 0)
   OR (c.comment_count IS NOT NULL AND c.comment_count > 0)
ORDER BY total_activity DESC, u.id
`

type GetUserActivitySinceRow struct {
	ID            int32
	Username      string
	TotalActivity int32
}

// Get user activity that has been updated since the given timestamp
// Returns users who have posted or commented since the given time
func (q *Queries) GetUserActivitySince(ctx context.Context, updatedAt sql.NullTime) ([]GetUserActivitySinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserActivitySince, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserActivitySinceRow
	for rows.Next() {
		var i GetUserActivitySinceRow
		if err := rows.Scan(&i.ID, &i.Username, &i.TotalActivity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSubredditActivityCount = `-- name: GetUserSubredditActivityCount :one
SELECT (
    (SELECT COUNT(*) FROM posts p WHERE p.author_id = $1 AND p.subreddit_id = $2) +
    (SELECT COUNT(*) FROM comments c WHERE c.author_id = $1 AND c.subreddit_id = $2)
) as activity_count
`

type GetUserSubredditActivityCountParams struct {
	AuthorID    int32
	SubredditID int32
}

func (q *Queries) GetUserSubredditActivityCount(ctx context.Context, arg GetUserSubredditActivityCountParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserSubredditActivityCount, arg.AuthorID, arg.SubredditID)
	var activity_count int32
	err := row.Scan(&activity_count)
	return activity_count, err
}

const getUserSubreddits = `-- name: GetUserSubreddits :many
SELECT DISTINCT s.id, s.name
FROM subreddits s
JOIN posts p ON p.subreddit_id = s.id
WHERE p.author_id = $1
UNION
SELECT DISTINCT s.id, s.name
FROM subreddits s
JOIN comments c ON c.subreddit_id = s.id
WHERE c.author_id = $1
`

type GetUserSubredditsRow struct {
	ID   int32
	Name string
}

func (q *Queries) GetUserSubreddits(ctx context.Context, authorID int32) ([]GetUserSubredditsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSubreddits, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSubredditsRow
	for rows.Next() {
		var i GetUserSubredditsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTotalActivity = `-- name: GetUserTotalActivity :one
SELECT (
    (SELECT COUNT(*) FROM posts p WHERE p.author_id = $1) +
    (SELECT COUNT(*) FROM comments c WHERE c.author_id = $1)
) as total_activity
`

func (q *Queries) GetUserTotalActivity(ctx context.Context, authorID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserTotalActivity, authorID)
	var total_activity int32
	err := row.Scan(&total_activity)
	return total_activity, err
}

const insertCommunityHierarchy = `-- name: InsertCommunityHierarchy :exec
INSERT INTO graph_community_hierarchy (
    node_id,
    level,
    community_id,
    parent_community_id,
    centroid_x,
    centroid_y,
    centroid_z
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) ON CONFLICT (node_id, level) DO UPDATE SET
    community_id = EXCLUDED.community_id,
    parent_community_id = EXCLUDED.parent_community_id,
    centroid_x = EXCLUDED.centroid_x,
    centroid_y = EXCLUDED.centroid_y,
    centroid_z = EXCLUDED.centroid_z
`

type InsertCommunityHierarchyParams struct {
	NodeID            string
	Level             int32
	CommunityID       int32
	ParentCommunityID sql.NullInt32
	CentroidX         sql.NullFloat64
	CentroidY         sql.NullFloat64
	CentroidZ         sql.NullFloat64
}

func (q *Queries) InsertCommunityHierarchy(ctx context.Context, arg InsertCommunityHierarchyParams) error {
	_, err := q.db.ExecContext(ctx, insertCommunityHierarchy,
		arg.NodeID,
		arg.Level,
		arg.CommunityID,
		arg.ParentCommunityID,
		arg.CentroidX,
		arg.CentroidY,
		arg.CentroidZ,
	)
	return err
}

const listGraphLinksAmong = `-- name: ListGraphLinksAmong :many
SELECT source, target
FROM graph_links
WHERE source = ANY($1::text[]) AND target = ANY($1::text[])
`

type ListGraphLinksAmongRow struct {
	Source string
	Target string
}

func (q *Queries) ListGraphLinksAmong(ctx context.Context, dollar_1 []string) ([]ListGraphLinksAmongRow, error) {
	rows, err := q.db.QueryContext(ctx, listGraphLinksAmong, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGraphLinksAmongRow
	for rows.Next() {
		var i ListGraphLinksAmongRow
		if err := rows.Scan(&i.Source, &i.Target); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGraphNodesByWeight = `-- name: ListGraphNodesByWeight :many
SELECT id, name, val, type, pos_x, pos_y, pos_z
FROM graph_nodes gn
ORDER BY (
    CASE WHEN gn.val ~ '^[0-9]+$' THEN CAST(gn.val AS BIGINT) ELSE 0 END
) DESC NULLS LAST, gn.id
LIMIT $1
`

type ListGraphNodesByWeightRow struct {
	ID   string
	Name string
	Val  sql.NullString
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

func (q *Queries) ListGraphNodesByWeight(ctx context.Context, limit int32) ([]ListGraphNodesByWeightRow, error) {
	rows, err := q.db.QueryContext(ctx, listGraphNodesByWeight, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGraphNodesByWeightRow
	for rows.Next() {
		var i ListGraphNodesByWeightRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGraphVersions = `-- name: ListGraphVersions :many
SELECT id, created_at, node_count, link_count, status, precalc_duration_ms, is_full_rebuild FROM graph_versions
ORDER BY id DESC
LIMIT $1 OFFSET $2
`

type ListGraphVersionsParams struct {
	Limit  int32
	Offset int32
}

// List recent graph versions with pagination
func (q *Queries) ListGraphVersions(ctx context.Context, arg ListGraphVersionsParams) ([]GraphVersion, error) {
	rows, err := q.db.QueryContext(ctx, listGraphVersions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GraphVersion
	for rows.Next() {
		var i GraphVersion
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.NodeCount,
			&i.LinkCount,
			&i.Status,
			&i.PrecalcDurationMs,
			&i.IsFullRebuild,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithActivity = `-- name: ListUsersWithActivity :many
SELECT
    u.id,
    u.username,
    COALESCE(p.post_count, 0) + COALESCE(c.comment_count, 0) AS total_activity
FROM users u
LEFT JOIN (
    SELECT author_id, CAST(COUNT(*) AS BIGINT) AS post_count
    FROM posts
    GROUP BY author_id
) p ON p.author_id = u.id
LEFT JOIN (
    SELECT author_id, CAST(COUNT(*) AS BIGINT) AS comment_count
    FROM comments
    GROUP BY author_id
) c ON c.author_id = u.id
ORDER BY total_activity DESC, u.id
`

type ListUsersWithActivityRow struct {
	ID            int32
	Username      string
	TotalActivity int32
}

func (q *Queries) ListUsersWithActivity(ctx context.Context) ([]ListUsersWithActivityRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersWithActivity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersWithActivityRow
	for rows.Next() {
		var i ListUsersWithActivityRow
		if err := rows.Scan(&i.ID, &i.Username, &i.TotalActivity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGraphNodes = `-- name: SearchGraphNodes :many
SELECT 
    id,
    name,
    CAST(val AS TEXT) as val,
    type,
    pos_x,
    pos_y,
    pos_z
FROM graph_nodes
WHERE 
    name ILIKE '%' || $1 || '%' 
    OR id ILIKE '%' || $1 || '%'
ORDER BY 
    CASE 
        WHEN LOWER(name) = LOWER($1) THEN 0
        WHEN LOWER(id) = LOWER($1) THEN 1
        ELSE 2
    END,
    CASE WHEN val ~ '^[0-9]+$' THEN CAST(val AS BIGINT) ELSE 0 END DESC
LIMIT $2
`

type SearchGraphNodesParams struct {
	Column1 sql.NullString
	Limit   int32
}

type SearchGraphNodesRow struct {
	ID   string
	Name string
	Val  string
	Type sql.NullString
	PosX sql.NullFloat64
	PosY sql.NullFloat64
	PosZ sql.NullFloat64
}

// Fuzzy search for graph nodes by name or ID
// Uses ILIKE for case-insensitive partial matching
// Orders results by exact match first, then by relevance (val/weight)
// Note: Leading wildcards prevent index usage and cause full table scans.
// For large datasets, consider adding a GIN or GiST index with pg_trgm extension.
func (q *Queries) SearchGraphNodes(ctx context.Context, arg SearchGraphNodesParams) ([]SearchGraphNodesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGraphNodes, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGraphNodesRow
	for rows.Next() {
		var i SearchGraphNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Val,
			&i.Type,
			&i.PosX,
			&i.PosY,
			&i.PosZ,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGraphNodePositions = `-- name: UpdateGraphNodePositions :exec
UPDATE graph_nodes g
SET pos_x = u.x, pos_y = u.y, pos_z = u.z, updated_at = now()
FROM (
    SELECT unnest($1::text[]) AS id,
           unnest($2::double precision[]) AS x,
           unnest($3::double precision[]) AS y,
           unnest($4::double precision[]) AS z
) AS u
WHERE g.id = u.id
`

type UpdateGraphNodePositionsParams struct {
	Column1 []string
	Column2 []float64
	Column3 []float64
	Column4 []float64
}

func (q *Queries) UpdateGraphNodePositions(ctx context.Context, arg UpdateGraphNodePositionsParams) error {
	_, err := q.db.ExecContext(ctx, updateGraphNodePositions,
		pq.Array(arg.Column1),
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
	)
	return err
}

const updateGraphVersionStatus = `-- name: UpdateGraphVersionStatus :exec
UPDATE graph_versions
SET status = $1, precalc_duration_ms = $2
WHERE id = $3
`

type UpdateGraphVersionStatusParams struct {
	Status            string
	PrecalcDurationMs sql.NullInt32
	ID                int64
}

// Update the status of a graph version
func (q *Queries) UpdateGraphVersionStatus(ctx context.Context, arg UpdateGraphVersionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateGraphVersionStatus, arg.Status, arg.PrecalcDurationMs, arg.ID)
	return err
}

const updatePrecalcState = `-- name: UpdatePrecalcState :exec
UPDATE precalc_state
SET 
    last_precalc_at = $1,
    last_full_precalc_at = COALESCE($2, last_full_precalc_at),
    total_nodes = $3,
    total_links = $4,
    precalc_duration_ms = $5,
    updated_at = now()
WHERE id = 1
`

type UpdatePrecalcStateParams struct {
	LastPrecalcAt     sql.NullTime
	LastFullPrecalcAt sql.NullTime
	TotalNodes        sql.NullInt32
	TotalLinks        sql.NullInt32
	PrecalcDurationMs sql.NullInt32
}

// Update the precalculation state after a run
func (q *Queries) UpdatePrecalcState(ctx context.Context, arg UpdatePrecalcStateParams) error {
	_, err := q.db.ExecContext(ctx, updatePrecalcState,
		arg.LastPrecalcAt,
		arg.LastFullPrecalcAt,
		arg.TotalNodes,
		arg.TotalLinks,
		arg.PrecalcDurationMs,
	)
	return err
}

const updatePrecalcStateVersion = `-- name: UpdatePrecalcStateVersion :exec
UPDATE precalc_state
SET current_version_id = $1
WHERE id = 1
`

// Update the current version ID in precalc_state
func (q *Queries) UpdatePrecalcStateVersion(ctx context.Context, currentVersionID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, updatePrecalcStateVersion, currentVersionID)
	return err
}
