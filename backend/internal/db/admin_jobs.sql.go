// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin_jobs.sql

package db

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const getAdminCrawlJobStats = `-- name: GetAdminCrawlJobStats :one
SELECT
  COUNT(*) FILTER (WHERE status = 'queued') AS queued_count,
  COUNT(*) FILTER (WHERE status = 'crawling') AS running_count,
  COUNT(*) FILTER (WHERE status = 'failed') AS failed_count,
  COUNT(*) FILTER (WHERE status = 'success') AS completed_count,
  COUNT(*) AS total_count
FROM crawl_jobs
`

type GetAdminCrawlJobStatsRow struct {
	QueuedCount    int64
	RunningCount   int64
	FailedCount    int64
	CompletedCount int64
	TotalCount     int64
}

func (q *Queries) GetAdminCrawlJobStats(ctx context.Context) (GetAdminCrawlJobStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAdminCrawlJobStats)
	var i GetAdminCrawlJobStatsRow
	err := row.Scan(
		&i.QueuedCount,
		&i.RunningCount,
		&i.FailedCount,
		&i.CompletedCount,
		&i.TotalCount,
	)
	return i, err
}

const getAllServiceSettings = `-- name: GetAllServiceSettings :many
SELECT key, value FROM service_settings ORDER BY key
`

func (q *Queries) GetAllServiceSettings(ctx context.Context) ([]ServiceSetting, error) {
	rows, err := q.db.QueryContext(ctx, getAllServiceSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceSetting
	for rows.Next() {
		var i ServiceSetting
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCrawlJobByID = `-- name: GetCrawlJobByID :one
SELECT 
  id,
  subreddit_id,
  status,
  retries,
  priority,
  last_attempt,
  enqueued_by,
  created_at,
  updated_at
FROM crawl_jobs
WHERE id = $1
`

type GetCrawlJobByIDRow struct {
	ID          int32
	SubredditID int32
	Status      string
	Retries     sql.NullInt32
	Priority    sql.NullInt32
	LastAttempt sql.NullTime
	EnqueuedBy  sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetCrawlJobByID(ctx context.Context, id int32) (GetCrawlJobByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCrawlJobByID, id)
	var i GetCrawlJobByIDRow
	err := row.Scan(
		&i.ID,
		&i.SubredditID,
		&i.Status,
		&i.Retries,
		&i.Priority,
		&i.LastAttempt,
		&i.EnqueuedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAdminAuditLog = `-- name: ListAdminAuditLog :many
SELECT
  id,
  action,
  resource_type,
  resource_id,
  user_id,
  details,
  ip_address,
  created_at
FROM admin_audit_log
ORDER BY created_at DESC
LIMIT $1::int OFFSET $2::int
`

type ListAdminAuditLogParams struct {
	Column1 int32
	Column2 int32
}

func (q *Queries) ListAdminAuditLog(ctx context.Context, arg ListAdminAuditLogParams) ([]AdminAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, listAdminAuditLog, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminAuditLog
	for rows.Next() {
		var i AdminAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.UserID,
			&i.Details,
			&i.IpAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrawlJobsByStatus = `-- name: ListCrawlJobsByStatus :many
SELECT
  cj.id,
  cj.subreddit_id,
  s.name AS subreddit_name,
  cj.status,
  cj.retries,
  cj.priority,
  cj.last_attempt,
  cj.enqueued_by,
  cj.created_at,
  cj.updated_at
FROM crawl_jobs cj
JOIN subreddits s ON s.id = cj.subreddit_id
WHERE cj.status = $1
ORDER BY cj.priority DESC, cj.created_at DESC
LIMIT $2::int OFFSET $3::int
`

type ListCrawlJobsByStatusParams struct {
	Status  string
	Column2 int32
	Column3 int32
}

type ListCrawlJobsByStatusRow struct {
	ID            int32
	SubredditID   int32
	SubredditName string
	Status        string
	Retries       sql.NullInt32
	Priority      sql.NullInt32
	LastAttempt   sql.NullTime
	EnqueuedBy    sql.NullString
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
}

func (q *Queries) ListCrawlJobsByStatus(ctx context.Context, arg ListCrawlJobsByStatusParams) ([]ListCrawlJobsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listCrawlJobsByStatus, arg.Status, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCrawlJobsByStatusRow
	for rows.Next() {
		var i ListCrawlJobsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.SubredditName,
			&i.Status,
			&i.Retries,
			&i.Priority,
			&i.LastAttempt,
			&i.EnqueuedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logAdminAction = `-- name: LogAdminAction :exec
INSERT INTO admin_audit_log (action, resource_type, resource_id, user_id, details, ip_address)
VALUES ($1, $2, $3, $4, $5, $6)
`

type LogAdminActionParams struct {
	Action       string
	ResourceType string
	ResourceID   sql.NullString
	UserID       string
	Details      pqtype.NullRawMessage
	IpAddress    sql.NullString
}

func (q *Queries) LogAdminAction(ctx context.Context, arg LogAdminActionParams) error {
	_, err := q.db.ExecContext(ctx, logAdminAction,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.UserID,
		arg.Details,
		arg.IpAddress,
	)
	return err
}

const retryCrawlJob = `-- name: RetryCrawlJob :exec
UPDATE crawl_jobs 
SET status = 'queued', retries = 0, updated_at = now() 
WHERE id = $1
`

func (q *Queries) RetryCrawlJob(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, retryCrawlJob, id)
	return err
}

const updateCrawlJobPriority = `-- name: UpdateCrawlJobPriority :exec
UPDATE crawl_jobs 
SET priority = $2, updated_at = now() 
WHERE id = $1
`

type UpdateCrawlJobPriorityParams struct {
	ID       int32
	Priority sql.NullInt32
}

func (q *Queries) UpdateCrawlJobPriority(ctx context.Context, arg UpdateCrawlJobPriorityParams) error {
	_, err := q.db.ExecContext(ctx, updateCrawlJobPriority, arg.ID, arg.Priority)
	return err
}

const updateCrawlJobStatus = `-- name: UpdateCrawlJobStatus :exec
UPDATE crawl_jobs 
SET status = $2, updated_at = now() 
WHERE id = $1
`

type UpdateCrawlJobStatusParams struct {
	ID     int32
	Status string
}

func (q *Queries) UpdateCrawlJobStatus(ctx context.Context, arg UpdateCrawlJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateCrawlJobStatus, arg.ID, arg.Status)
	return err
}
